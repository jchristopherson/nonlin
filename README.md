# nonlin
A library that provides routines to compute the solutions to systems of nonlinear equations.

## Example 1
This example solves a set of two equations of two unknowns using a Quasi-Newton type solver.  In this example, the solver is left to compute the derivatives numerically.

```fortran

    ! Define the routine containing the eqations to solve.  The equations are:
    ! x**2 + y**2 = 34
    ! x**2 - 2 * y**2 = 7
    subroutine fcns(x, f)
        real(dp), intent(in), dimension(:) :: x
        real(dp), intent(out), dimension(:) :: f
        f(1) = x(1)**2 + x(2)**2 - 34.0d0
        f(2) = x(1)**2 - 2.0d0 * x(2)**2 - 7.0d0
    end subroutine

    ! ...

    ! Solver Code
    type(vecfcn_helper) :: obj
    procedure(vecfcn), pointer :: fcn
    type(quasi_newton_solver) :: solver
    real(dp) :: x(2), f(2)

    ! Define an initial guess
    x = [1.0d0, 1.0d0]

    ! Solve
    call solver%solve(obj, x, f)
    
```

## Example 2
This example uses a least-squares approach to determine the coefficients of a polynomial that best fits a set of data.

```fortran
    ! The function containing the data to fit
    subroutine lsfcn1(x, f)
        ! Arguments
        real(dp), intent(in), dimension(:) :: x  ! Contains the coefficients
        real(dp), intent(out), dimension(:) :: f

        ! Local Variables
        real(dp), dimension(21) :: xp, yp

        ! Data to fit (21 data points)
        xp = [0.0d0, 0.1d0, 0.2d0, 0.3d0, 0.4d0, 0.5d0, 0.6d0, 0.7d0, 0.8d0, &
            0.9d0, 1.0d0, 1.1d0, 1.2d0, 1.3d0, 1.4d0, 1.5d0, 1.6d0, 1.7d0, &
            1.8d0, 1.9d0, 2.0d0]
        yp = [1.216737514d0, 1.250032542d0, 1.305579195d0, 1.040182335d0, &
            1.751867738d0, 1.109716707d0, 2.018141531d0, 1.992418729d0, &
            1.807916923d0, 2.078806005d0, 2.698801324d0, 2.644662712d0, &
            3.412756702d0, 4.406137221d0, 4.567156645d0, 4.999550779d0, &
            5.652854194d0, 6.784320119d0, 8.307936836d0, 8.395126494d0, &
            10.30252404d0]
        
        ! We'll apply a cubic polynomial model to this data:
        ! y = c1 * x**3 + c2 * x**2 + c3 * x + c4
        f = x(1) * xp**3 + x(2) * xp**2 + x(3) * xp + x(4) - yp

        ! For reference, the data was generated by adding random errors to
        ! the following polynomial: y = x**3 - 0.3 * x**2 + 1.2 * x + 0.3
    end subroutine

    ! ...

    ! Solver Code ...

    ! Local Variables
    type(vecfcn_helper) :: obj
    procedure(vecfcn), pointer :: fcn
    type(least_squares_solver) :: solver
    real(dp) :: x(4), f(21) ! There are 4 coefficients and 21 data points

    ! Initialization
    fcn => lsfcn1
    x = 1.0d0   ! Set X to an initial guess of [1, 1, 1, 1]
    call obj%set_fcn(fcn, 21, 4)

    ! Compute the solution, and store the polynomial coefficients in X
    call solver%solve(obj, x, f)

```
The example yields the following coefficients:
- c1: 1.064762757
- c2: -0.122320291
- c3: 0.446613446
- c4: 1.186614224

These coefficients yield a maximum residual of 0.5064.