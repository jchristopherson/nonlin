# nonlin
A library that provides routines to compute the solutions to systems of nonlinear equations.

## Example 1
This example solves a set of two equations of two unknowns using a Quasi-Newton type solver.  In this example, the solver is left to compute the derivatives numerically.

```fortran

    ! Define the routine containing the eqations to solve.  The equations are:
    ! x**2 + y**2 = 34
    ! x**2 - 2 * y**2 = 7
    subroutine fcns(x, f)
        real(dp), intent(in), dimension(:) :: x
        real(dp), intent(out), dimension(:) :: f
        f(1) = x(1)**2 + x(2)**2 - 34.0d0
        f(2) = x(1)**2 - 2.0d0 * x(2)**2 - 7.0d0
    end subroutine

    ! ...

    ! Solver Code
    type(vecfcn_helper) :: obj
    procedure(vecfcn), pointer :: fcn
    type(quasi_newton_solver) :: solver
    real(dp) :: x(2), f(2)

    ! Define an initial guess
    x = [1.0d0, 1.0d0]

    ! Solve
    call solver%solve(obj, x, f)
    
```
The example yields the solution vector: x = [5.0, 3.0], with a maximum residual of 0.121e-9.  The solution converged in a total of 10 iterations, with 2 Jacobian evaluations, and 14 additional function evaluations.

## Example 2
This example uses a least-squares approach to determine the coefficients of a polynomial that best fits a set of data.

```fortran
    ! The function containing the data to fit
    subroutine lsfcn1(x, f)
        ! Arguments
        real(dp), intent(in), dimension(:) :: x  ! Contains the coefficients
        real(dp), intent(out), dimension(:) :: f

        ! Local Variables
        real(dp), dimension(21) :: xp, yp

        ! Data to fit (21 data points)
        xp = [0.0d0, 0.1d0, 0.2d0, 0.3d0, 0.4d0, 0.5d0, 0.6d0, 0.7d0, 0.8d0, &
            0.9d0, 1.0d0, 1.1d0, 1.2d0, 1.3d0, 1.4d0, 1.5d0, 1.6d0, 1.7d0, &
            1.8d0, 1.9d0, 2.0d0]
        yp = [1.216737514d0, 1.250032542d0, 1.305579195d0, 1.040182335d0, &
            1.751867738d0, 1.109716707d0, 2.018141531d0, 1.992418729d0, &
            1.807916923d0, 2.078806005d0, 2.698801324d0, 2.644662712d0, &
            3.412756702d0, 4.406137221d0, 4.567156645d0, 4.999550779d0, &
            5.652854194d0, 6.784320119d0, 8.307936836d0, 8.395126494d0, &
            10.30252404d0]
        
        ! We'll apply a cubic polynomial model to this data:
        ! y = c1 * x**3 + c2 * x**2 + c3 * x + c4
        f = x(1) * xp**3 + x(2) * xp**2 + x(3) * xp + x(4) - yp

        ! For reference, the data was generated by adding random errors to
        ! the following polynomial: y = x**3 - 0.3 * x**2 + 1.2 * x + 0.3
    end subroutine

    ! ...

    ! Solver Code
    type(vecfcn_helper) :: obj
    procedure(vecfcn), pointer :: fcn
    type(least_squares_solver) :: solver
    real(dp) :: x(4), f(21) ! There are 4 coefficients and 21 data points

    ! Initialization
    fcn => lsfcn1
    x = 1.0d0   ! Set X to an initial guess of [1, 1, 1, 1]
    call obj%set_fcn(fcn, 21, 4)

    ! Compute the solution, and store the polynomial coefficients in X
    call solver%solve(obj, x, f)

```
The example yields the following coefficients:
- c1: 1.064762757
- c2: -0.122320291
- c3: 0.446613446
- c4: 1.186614224

These coefficients yield a maximum residual of 0.5064.

The following graph illustrates the fit.
![](images/Curve_Fit_Example_1.png?raw=true)

## C Example 1
This example illustrates the C equivalent to Example 1 from above.
```c
#include <stdio.h>
#include <stdlib.h>
#include "include/nonlin.h"

void testfcn(int neqn, int nvar, const double *x, double *f);

int main() {
    // Local Variables
    solver_control tol;
    line_search_control ls;
    iteration_behavior ib;
    double x[2], f[2];

    // Initialization
    tol.max_evals = 500;
    tol.fcn_tolerance = 1.0e-8;
    tol.var_tolerances = 1.0e-12;
    tol.grad_tolerances = 1.0e-12;
    tol.print_status = true;
    ls.max_evals = 100;
    ls.alpha = 1.0e-4;
    ls.factor = 0.1;
    x[0] = 1.0;
    x[1] = 1.0;

    // Compute the solution using a Quasi-Newton method
    solve_quasi_newton(testfcn, NULL, 2, x, f, &tol, &ls, &ib, NULL);

    // Display the results
    printf("\nRESULTS:\nX = (%f, %f)\nF = (%e, %e)\n", x[0], x[1], f[0], f[1]);
    printf("Iterations: %i\nFunction Evaluations: %i\nJacobian Evaluations: %i\n",
           ib.iter_count, ib.fcn_count, ib.jacobian_count);

    // End
    return 0;
}


void testfcn(int neqn, int nvar, const double *x, double *f) {
    f[0] = x[0] * x[0] + x[1] * x[1] - 34.0;
    f[1] = x[0] * x[0] - 2.0 * x[1] * x[1] - 7.0;
}
```
The output of the above is as follows:

Iteration: 1
Function Evaluations: 3
Jacobian Evaluations: 1
Change in Variable: .545E+00
Residual: .272E+02

Iteration: 2
Function Evaluations: 5
Jacobian Evaluations: 1
Change in Variable: .327E+00
Residual: .196E+02

Iteration: 3
Function Evaluations: 6
Jacobian Evaluations: 1
Change in Variable: .473E+00
Residual: .128E+02

Iteration: 4
Function Evaluations: 7
Jacobian Evaluations: 1
Change in Variable: .378E+00
Residual: .377E+01

Iteration: 5
Function Evaluations: 9
Jacobian Evaluations: 1
Change in Variable: .768E-01
Residual: .157E+01

Iteration: 6
Function Evaluations: 10
Jacobian Evaluations: 1
Change in Variable: .253E-01
Residual: .689E+00

Iteration: 7
Function Evaluations: 11
Jacobian Evaluations: 2
Change in Variable: .136E-01
Residual: .288E-02

Iteration: 8
Function Evaluations: 12
Jacobian Evaluations: 2
Change in Variable: .927E-04
Residual: .324E-04

Iteration: 9
Function Evaluations: 13
Jacobian Evaluations: 2
Change in Variable: .791E-06
Residual: .406E-07

RESULTS:
X = (5.000000, 3.000000)
F = (6.038903e-011, 1.206786e-010)
Iterations: 10
Function Evaluations: 14
Jacobian Evaluations: 2
