var tipuesearch = {"pages":[{"title":" NONLIN ","text":"NONLIN Developer Info Jason Christopherson","tags":"home","loc":"index.html"},{"title":"least_squares_solver – NONLIN ","text":"type, public, extends( equation_solver ) :: least_squares_solver @brief Defines a Levenberg-Marquardt based solver for unconstrained\nleast-squares problems.\nDefines a Levenberg-Marquardt based solver for unconstrained\nleast-squares problems. Contents Type-Bound Procedures get_fcn_tolerance get_gradient_tolerance get_max_fcn_evals get_print_status get_step_scaling_factor get_var_tolerance set_fcn_tolerance set_gradient_tolerance set_max_fcn_evals set_print_status set_step_scaling_factor set_var_tolerance solve Type-Bound Procedures procedure, public :: get_fcn_tolerance => es_get_fcn_tol private pure function es_get_fcn_tol(this) result(x) Gets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_gradient_tolerance => es_get_grad_tol private pure function es_get_grad_tol(this) result(x) Gets the convergence on slope of the gradient vector\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_max_fcn_evals => es_get_max_eval private pure function es_get_max_eval(this) result(n) Gets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => es_get_print_status private pure function es_get_print_status(this) result(x) Gets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_step_scaling_factor => lss_get_factor private pure function lss_get_factor(this) result(x) Gets a factor used to scale the bounds on the initial step. This factor is used to set the bounds on the initial step such that \nthe initial step is bounded as the product of the factor with the \nEuclidean norm of the vector resulting from multiplication of the \ndiagonal scaling matrix and the solution estimate.  If zero, the \nfactor itself is used. Arguments Type Intent Optional Attributes Name class( least_squares_solver ), intent(in) :: this The least_squares_solver object. Return Value real(kind=real64) The factor. procedure, public :: get_var_tolerance => es_get_var_tol private pure function es_get_var_tol(this) result(x) Gets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: set_fcn_tolerance => es_set_fcn_tol private  subroutine es_set_fcn_tol(this, x) Sets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_gradient_tolerance => es_set_grad_tol private  subroutine es_set_grad_tol(this, x) Sets the convergence on slope of the gradient vector tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_max_fcn_evals => es_set_max_eval private  subroutine es_set_max_eval(this, n) Sets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => es_set_print_status private  subroutine es_set_print_status(this, x) Sets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_step_scaling_factor => lss_set_factor private  subroutine lss_set_factor(this, x) Sets a factor used to scale the bounds on the initial step. This factor is used to set the bounds on the initial step such that \nthe initial step is bounded as the product of the factor with the \nEuclidean norm of the vector resulting from multiplication of the \ndiagonal scaling matrix and the solution estimate.  If zero, the \nfactor itself is used. Arguments Type Intent Optional Attributes Name class( least_squares_solver ), intent(inout) :: this The least_squares_solver object. real(kind=real64), intent(in) :: x The factor. procedure, public :: set_var_tolerance => es_set_var_tol private  subroutine es_set_var_tol(this, x) Sets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: solve => lss_solve private  subroutine lss_solve(this, fcn, x, fvec, ib, err) Applies the Levenberg-Marquardt method to solve the nonlinear\nleast-squares problem.  This routines is based upon the MINPACK \nroutine LMDIF. Arguments Type Intent Optional Attributes Name class( least_squares_solver ), intent(inout) :: this The least_squares_solver object. class( vecfcn_helper ), intent(in) :: fcn The vecfcn_helper object containing the equations to solve. real(kind=real64), intent(inout), dimension(:) :: x On input, an N-element array containing an initial estimate \nto the solution.  On output, the updated solution estimate.\nN is the number of variables. real(kind=real64), intent(out), dimension(:) :: fvec An M-element array that, on output, will contain the values \nof each equation as evaluated at the variable values given \nin x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\least_squares_solver.html"},{"title":"line_search – NONLIN ","text":"type, public :: line_search Defines a type capable of performing an inexact, backtracking line\nsearch to find a point as far along the specified direction vector \nthat is usable for unconstrained minimization problems. See Also: Wikipedia Oxfford Lecture Notes Wolfram Numerical Recipes Contents Type-Bound Procedures get_distance_factor get_max_fcn_evals get_scaling_factor ls_search_mimo ls_search_miso search set_distance_factor set_max_fcn_evals set_scaling_factor Type-Bound Procedures procedure, public :: get_distance_factor => ls_get_dist private pure function ls_get_dist(this) result(x) Gets a distance factor defining the minimum distance along the\nsearch direction vector is practical. Arguments Type Intent Optional Attributes Name class( line_search ), intent(in) :: this The line_search object. Return Value real(kind=real64) The distance factor.  A value of 1 indicates the full length\nof the vector. procedure, public :: get_max_fcn_evals => ls_get_max_eval private pure function ls_get_max_eval(this) result(n) Gets the maximum number of function evaluations allowed during a\nsingle line search. Arguments Type Intent Optional Attributes Name class( line_search ), intent(in) :: this The line_search object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_scaling_factor => ls_get_scale private pure function ls_get_scale(this) result(x) Gets the scaling of the product of the gradient and direction\nvectors such that , where is the search direction vector, is the gradient vector, \nand is the scaling factor. Arguments Type Intent Optional Attributes Name class( line_search ), intent(in) :: this The line_search object. Return Value real(kind=real64) The scaling factor. procedure, public,  :: ls_search_mimo private  subroutine ls_search_mimo(this, fcn, xold, grad, dir, x, fvec, fold, fx, ib, err) Utilizes an inexact, backtracking line search to find a point as\nfar along the specified direction vector that is usable for \nunconstrained minimization problems. Arguments Type Intent Optional Attributes Name class( line_search ), intent(in) :: this The line_search object. class( vecfcn_helper ), intent(in) :: fcn A vecfcn_helper object containing the system of equations. real(kind=real64), intent(in), dimension(:) :: xold An N-element array defining the initial point, where N is the \nnumber of variables. real(kind=real64), intent(in), dimension(:) :: grad An N-element array defining the gradient of fcn evaluated at \nxold. real(kind=real64), intent(in), dimension(:) :: dir An N-element array defining the search direction. real(kind=real64), intent(out), dimension(:) :: x An N-element array where the updated solution point will be \nwritten. real(kind=real64), intent(out), dimension(:) :: fvec An M-element array containing the M equation values evaluated at\nx, where M is the number of equations. real(kind=real64), intent(in), optional :: fold An optional input that provides the value resulting from: .  If not \nprovided, fcn is evalauted at xold, and the aforementioned \nrelationship is computed. real(kind=real64), intent(out), optional :: fx The result of the operation: . type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to\nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public,  :: ls_search_miso private  subroutine ls_search_miso(this, fcn, xold, grad, dir, x, fold, fx, ib, err) Utilizes an inexact, backtracking line search to find a point as far \nalong the specified direction vector that is usable for unconstrained\nminimization problems. Arguments Type Intent Optional Attributes Name class( line_search ), intent(in) :: this The line_search object. class( fcnnvar_helper ), intent(in) :: fcn A fcnnvar_helper object containing the system of equations. real(kind=real64), intent(in), dimension(:) :: xold An N-element array defining the initial point, where N is the \nnumber of variables. real(kind=real64), intent(in), dimension(:) :: grad An N-element array defining the gradient of fcn evaluated at \nxold. real(kind=real64), intent(in), dimension(:) :: dir An N-element array defining the search direction. real(kind=real64), intent(out), dimension(:) :: x An N-element array where the updated solution point will be \nwritten. real(kind=real64), intent(in), optional :: fold An optional input that provides the function value at xold.  If \nnot provided, fcn is evalauted at xold. real(kind=real64), intent(out), optional :: fx The value of the function as evaluated at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to\nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object. generic, public :: search => ls_search_mimo , ls_search_miso private  subroutine ls_search_mimo(this, fcn, xold, grad, dir, x, fvec, fold, fx, ib, err) Utilizes an inexact, backtracking line search to find a point as\nfar along the specified direction vector that is usable for \nunconstrained minimization problems. Arguments Type Intent Optional Attributes Name class( line_search ), intent(in) :: this The line_search object. class( vecfcn_helper ), intent(in) :: fcn A vecfcn_helper object containing the system of equations. real(kind=real64), intent(in), dimension(:) :: xold An N-element array defining the initial point, where N is the \nnumber of variables. real(kind=real64), intent(in), dimension(:) :: grad An N-element array defining the gradient of fcn evaluated at \nxold. real(kind=real64), intent(in), dimension(:) :: dir An N-element array defining the search direction. real(kind=real64), intent(out), dimension(:) :: x An N-element array where the updated solution point will be \nwritten. real(kind=real64), intent(out), dimension(:) :: fvec An M-element array containing the M equation values evaluated at\nx, where M is the number of equations. real(kind=real64), intent(in), optional :: fold An optional input that provides the value resulting from: .  If not \nprovided, fcn is evalauted at xold, and the aforementioned \nrelationship is computed. real(kind=real64), intent(out), optional :: fx The result of the operation: . type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to\nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object. private  subroutine ls_search_miso(this, fcn, xold, grad, dir, x, fold, fx, ib, err) Utilizes an inexact, backtracking line search to find a point as far \nalong the specified direction vector that is usable for unconstrained\nminimization problems. Arguments Type Intent Optional Attributes Name class( line_search ), intent(in) :: this The line_search object. class( fcnnvar_helper ), intent(in) :: fcn A fcnnvar_helper object containing the system of equations. real(kind=real64), intent(in), dimension(:) :: xold An N-element array defining the initial point, where N is the \nnumber of variables. real(kind=real64), intent(in), dimension(:) :: grad An N-element array defining the gradient of fcn evaluated at \nxold. real(kind=real64), intent(in), dimension(:) :: dir An N-element array defining the search direction. real(kind=real64), intent(out), dimension(:) :: x An N-element array where the updated solution point will be \nwritten. real(kind=real64), intent(in), optional :: fold An optional input that provides the function value at xold.  If \nnot provided, fcn is evalauted at xold. real(kind=real64), intent(out), optional :: fx The value of the function as evaluated at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to\nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: set_distance_factor => ls_set_dist private  subroutine ls_set_dist(this, x) Sets a distance factor defining the minimum distance along the\nsearch direction vector is practical. Arguments Type Intent Optional Attributes Name class( line_search ), intent(inout) :: this The line_search object. real(kind=real64), intent(in) :: x The distance factor.  A value of 1 indicates the full length\nof the vector.  Notice, this value is restricted to lie in the \nset [0.1, 1.0). procedure, public :: set_max_fcn_evals => ls_set_max_eval private  subroutine ls_set_max_eval(this, x) Sets the maximum number of function evaluations allowed during a\nsingle line search. Arguments Type Intent Optional Attributes Name class( line_search ), intent(inout) :: this The line_search object. integer(kind=int32), intent(in) :: x The maximum number of function evaluations. procedure, public :: set_scaling_factor => ls_set_scale private  subroutine ls_set_scale(this, x) Sets the scaling of the product of the gradient and direction\nvectors such that , where is the search direction vector, is the gradient vector, \nand is the scaling factor. Arguments Type Intent Optional Attributes Name class( line_search ), intent(inout) :: this The line_search object. real(kind=real64), intent(in) :: x The scaling factor.","tags":"","loc":"type\\line_search.html"},{"title":"equation_solver – NONLIN ","text":"type, public, abstract :: equation_solver A base class for various solvers of nonlinear systems of equations. Contents Type-Bound Procedures get_fcn_tolerance get_gradient_tolerance get_max_fcn_evals get_print_status get_var_tolerance set_fcn_tolerance set_gradient_tolerance set_max_fcn_evals set_print_status set_var_tolerance solve Type-Bound Procedures procedure, public :: get_fcn_tolerance => es_get_fcn_tol private pure function es_get_fcn_tol(this) result(x) Gets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_gradient_tolerance => es_get_grad_tol private pure function es_get_grad_tol(this) result(x) Gets the convergence on slope of the gradient vector\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_max_fcn_evals => es_get_max_eval private pure function es_get_max_eval(this) result(n) Gets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => es_get_print_status private pure function es_get_print_status(this) result(x) Gets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_var_tolerance => es_get_var_tol private pure function es_get_var_tol(this) result(x) Gets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: set_fcn_tolerance => es_set_fcn_tol private  subroutine es_set_fcn_tol(this, x) Sets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_gradient_tolerance => es_set_grad_tol private  subroutine es_set_grad_tol(this, x) Sets the convergence on slope of the gradient vector tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_max_fcn_evals => es_set_max_eval private  subroutine es_set_max_eval(this, n) Sets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => es_set_print_status private  subroutine es_set_print_status(this, x) Sets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_var_tolerance => es_set_var_tol private  subroutine es_set_var_tol(this, x) Sets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure( nonlin_solver ), public, deferred, pass :: solve subroutine nonlin_solver(this, fcn, x, fvec, ib, err) Prototype Describes the interface of a nonlinear equation solver. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver -based object. class( vecfcn_helper ), intent(in) :: fcn The vecfcn_helper object containing the equations to\nsolve. real(kind=real64), intent(inout), dimension(:) :: x On input, an N-element array containing an initial estimate \nto the solution.  On output, the updated solution estimate.\nN is the number of variables. real(kind=real64), intent(out), dimension(:) :: fvec An M-element array that, on output, will contain the values \nof each equation as evaluated at the variable values given \nin x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\equation_solver.html"},{"title":"vecfcn_helper – NONLIN ","text":"type, public :: vecfcn_helper Defines a type capable of encapsulating a system of nonlinear\nequations of the form: F(X) = 0.  This type is used to establish the\nsystem of equations to solve, and provides a means for computing\nthe Jacobian matrix for the system of equations, and any other\nancillary operations that may be needed by the solver. Contents Variables m_nvar Type-Bound Procedures fcn get_equation_count get_variable_count is_fcn_defined is_jacobian_defined jacobian set_fcn set_jacobian Components Type Visibility Attributes Name Initial integer(kind=int32), public :: m_nvar = 0 The number of variables in m_fcn. Type-Bound Procedures procedure, public :: fcn => vfh_fcn private  subroutine vfh_fcn(this, x, f) Executes the routine containing the system of equations to\nsolve.  No action is taken if the pointer to the subroutine has not\nbeen defined. Arguments Type Intent Optional Attributes Name class( vecfcn_helper ), intent(in) :: this The vecfcn_helper object. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variables. real(kind=real64), intent(out), dimension(:) :: f An M-element array that, on output, contains the values\nof the M functions. procedure, public :: get_equation_count => vfh_get_nfcn private  function vfh_get_nfcn(this) result(n) Gets the number of equations in this system. Arguments Type Intent Optional Attributes Name class( vecfcn_helper ), intent(in) :: this The vecfcn_helper object. Return Value integer(kind=int32) The function count. procedure, public :: get_variable_count => vfh_get_nvar private  function vfh_get_nvar(this) result(n) Gets the number of variables in this system. Arguments Type Intent Optional Attributes Name class( vecfcn_helper ), intent(in) :: this The vecfcn_helper object. Return Value integer(kind=int32) The number of variables. procedure, public :: is_fcn_defined => vfh_is_fcn_defined private  function vfh_is_fcn_defined(this) result(x) Tests if the pointer to the subroutine containing the system\nof equations to solve has been assigned. Arguments Type Intent Optional Attributes Name class( vecfcn_helper ), intent(in) :: this The vecfcn_helper object. Return Value logical Returns true if the pointer has been assigned; else, false. procedure, public :: is_jacobian_defined => vfh_is_jac_defined private  function vfh_is_jac_defined(this) result(x) Tests if the pointer to the Jacobian calculation routine has been\ndefined. Arguments Type Intent Optional Attributes Name class( vecfcn_helper ), intent(in) :: this The vecfcn_helper object. Return Value logical Returns true if the pointer has been assigned; else, false. procedure, public :: jacobian => vfh_jac_fcn private  subroutine vfh_jac_fcn(this, x, jac, fv, work, olwork, err) Executes the routine containing the Jacobian matrix if\nsupplied.  If not supplied, the Jacobian is computed via finite\ndifferences. Arguments Type Intent Optional Attributes Name class( vecfcn_helper ), intent(in) :: this The vecfcn_helper object. real(kind=real64), intent(inout), dimension(:) :: x An N-element array containing the independent variables defining \nthe point about which the derivatives will be calculated. real(kind=real64), intent(out), dimension(:,:) :: jac An M-by-N matrix where, on output, the Jacobian will\nbe written. real(kind=real64), intent(in), optional, dimension(:), target :: fv An optional M-element array containing the function values at x. \nIf not supplied, the function values are computed at x. real(kind=real64), intent(out), optional, dimension(:), target :: work An optional input, that if provided, prevents any local memory \nallocation.  If not provided, the memory required is allocated\nwithin.  If provided, the length of the array must be at least\nolwork.  Notice, a workspace array is only utilized if the user \ndoes not provide a routine for computing the Jacobian. integer(kind=int32), intent(out), optional :: olwork An optional output used to determine workspace size. If supplied, \nthe routine determines the optimal size for work, and returns \nwithout performing any actual calculations. integer(kind=int32), intent(out), optional :: err An optional integer output that can be used to determine\nerror status.  If not used, and an error is encountered, the \nroutine simply returns silently.  If used, the following error \ncodes identify error status: 0: No error has occurred. n: A positive integer denoting the index of an invalid input. -1: Indicates internal memory allocation failed. procedure, public :: set_fcn => vfh_set_fcn private  subroutine vfh_set_fcn(this, fcn, nfcn, nvar) Establishes a pointer to the routine containing the system of\nequations to solve. Arguments Type Intent Optional Attributes Name class( vecfcn_helper ), intent(inout) :: this The vecfcn_helper object. procedure( vecfcn ), intent(in), pointer :: fcn The function pointer. integer(kind=int32), intent(in) :: nfcn The number of functions. integer(kind=int32), intent(in) :: nvar The number of variables. procedure, public :: set_jacobian => vfh_set_jac private  subroutine vfh_set_jac(this, jac) Establishes a pointer to the routine for computing the\nJacobian matrix of the system of equations.  If no routine is\ndefined, the Jacobian matrix will be computed numerically (this is\nthe default state). Arguments Type Intent Optional Attributes Name class( vecfcn_helper ), intent(inout) :: this The vecfcn_helper object. procedure( jacobianfcn ), intent(in), pointer :: jac The function pointer.","tags":"","loc":"type\\vecfcn_helper.html"},{"title":"equation_optimizer – NONLIN ","text":"type, public, abstract :: equation_optimizer A base class for optimization of an equation of multiple variables. Contents Type-Bound Procedures get_max_fcn_evals get_print_status get_tolerance set_max_fcn_evals set_print_status set_tolerance solve Type-Bound Procedures procedure, public :: get_max_fcn_evals => oe_get_max_eval private pure function oe_get_max_eval(this) result(n) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => oe_get_print_status private pure function oe_get_print_status(this) result(x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_tolerance => oe_get_tol private pure function oe_get_tol(this) result(x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value real(kind=real64) The tolerance. procedure, public :: set_max_fcn_evals => oe_set_max_eval private  subroutine oe_set_max_eval(this, n) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => oe_set_print_status private  subroutine oe_set_print_status(this, x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_tolerance => oe_set_tol private  subroutine oe_set_tol(this, x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. real(kind=real64), intent(in) :: x The tolerance. procedure( nonlin_optimize_fcn ), public, deferred, pass :: solve subroutine nonlin_optimize_fcn(this, fcn, x, fout, ib, err) Prototype Describes the interface of a routine for optimizing an\nequation of N variables. Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. class( fcnnvar_helper ), intent(in) :: fcn The fcnnvar_helper object containing the equation to\noptimize. real(kind=real64), intent(inout), dimension(:) :: x On input, the initial guess at the optimal point.  On \noutput, the updated optimal point estimate. real(kind=real64), intent(out), optional :: fout An optional output, that if provided, returns the value of \nthe function at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\equation_optimizer.html"},{"title":"fcnnvar_helper – NONLIN ","text":"type, public :: fcnnvar_helper Defines a type capable of encapsulating an equation of N variables. Contents Type-Bound Procedures fcn get_variable_count gradient is_fcn_defined is_gradient_defined set_fcn set_gradient_fcn Type-Bound Procedures procedure, public :: fcn => fnh_fcn private  function fnh_fcn(this, x) result(f) Executes the routine containing the function to evaluate. Arguments Type Intent Optional Attributes Name class( fcnnvar_helper ), intent(in) :: this The fcnnvar_helper object. real(kind=real64), intent(in), dimension(:) :: x The value of the independent variables at which the function\nshould be evaluated. Return Value real(kind=real64) The value of the function. procedure, public :: get_variable_count => fnh_get_nvar private  function fnh_get_nvar(this) result(n) Gets the number of variables in this system. Arguments Type Intent Optional Attributes Name class( fcnnvar_helper ), intent(in) :: this The fcnnvar_helper object. Return Value integer(kind=int32) The number of variables. procedure, public :: gradient => fnh_grad_fcn private  subroutine fnh_grad_fcn(this, x, g, fv, err) Computes the gradient of the function. Arguments Type Intent Optional Attributes Name class( fcnnvar_helper ), intent(in) :: this The fcnnvar_helper object. real(kind=real64), intent(inout), dimension(:) :: x An N-element array containing the independent variables defining \nthe point about which the derivatives will be calculated.  This\narray is restored upon output. real(kind=real64), intent(out), dimension(:) :: g An N-element array where the gradient will be written upon\noutput. real(kind=real64), intent(in), optional :: fv An optional input providing the function value at x. integer(kind=int32), intent(out), optional :: err An optional integer output that can be used to determine error \nstatus.  If not used, and an error is encountered, the routine\nsimply returns silently.  If used, the following error codes \nidentify error status: 0: No error has occurred. n: A positive integer denoting the index of an invalid input. procedure, public :: is_fcn_defined => fnh_is_fcn_defined private  function fnh_is_fcn_defined(this) result(x) Tests if the pointer to the function has been assigned. Arguments Type Intent Optional Attributes Name class( fcnnvar_helper ), intent(in) :: this The fcnnvar_helper object. Return Value logical Returns true if the pointer has been assigned; else, false. procedure, public :: is_gradient_defined => fnh_is_grad_defined private  function fnh_is_grad_defined(this) result(x) Tests if the pointer to the routine containing the gradient\nhas been assigned. Arguments Type Intent Optional Attributes Name class( fcnnvar_helper ), intent(in) :: this The fcnnvar_helper object. Return Value logical Returns true if the pointer has been assigned; else, false. procedure, public :: set_fcn => fnh_set_fcn private  subroutine fnh_set_fcn(this, fcn, nvar) Establishes a pointer to the routine containing the function. Arguments Type Intent Optional Attributes Name class( fcnnvar_helper ), intent(inout) :: this The fcnnvar_helper object. procedure( fcnnvar ), intent(in), pointer :: fcn The function pointer. integer(kind=int32), intent(in) :: nvar The number of variables in the function. procedure, public :: set_gradient_fcn => fnh_set_grad private  subroutine fnh_set_grad(this, fcn) Establishes a pointer to the routine containing the gradient\nvector of the function. Arguments Type Intent Optional Attributes Name class( fcnnvar_helper ), intent(inout) :: this The fcnnvar_helper object. procedure( gradientfcn ), intent(in), pointer :: fcn The pointer to the gradient routine.","tags":"","loc":"type\\fcnnvar_helper.html"},{"title":"bfgs – NONLIN ","text":"type, public, extends( line_search_optimizer ) :: bfgs Defines a Broyden–Fletcher–Goldfarb–Shanno (BFGS) solver for\nminimization of functions of multiple variables. See Also: Wikipedia - BFGS Methods Wikipedia - Quasi-Newton Methods minFunc Contents Type-Bound Procedures get_line_search get_max_fcn_evals get_print_status get_tolerance get_use_line_search get_var_tolerance is_line_search_defined set_default_line_search set_line_search set_max_fcn_evals set_print_status set_tolerance set_use_line_search set_var_tolerance solve Type-Bound Procedures procedure, public :: get_line_search => lso_get_line_search private  subroutine lso_get_line_search(this, ls) Gets the line search module. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(in) :: this The line_search_optimizer object. class( line_search ), intent(out), allocatable :: ls The line_search object. procedure, public :: get_max_fcn_evals => oe_get_max_eval private pure function oe_get_max_eval(this) result(n) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => oe_get_print_status private pure function oe_get_print_status(this) result(x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_tolerance => oe_get_tol private pure function oe_get_tol(this) result(x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value real(kind=real64) The tolerance. procedure, public :: get_use_line_search => lso_get_use_search private pure function lso_get_use_search(this) result(x) Gets a value determining if a line-search should be employed. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(in) :: this The line_search_optimizer object. Return Value logical Returns true if a line search should be used; else, false. procedure, public :: get_var_tolerance => lso_get_var_tol private pure function lso_get_var_tol(this) result(x) Gets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(in) :: this The line_search_optimizer object. Return Value real(kind=real64) The tolerance value. procedure, public :: is_line_search_defined => lso_is_line_search_defined private pure function lso_is_line_search_defined(this) result(x) Tests to see if a line search module is defined. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(in) :: this The line_search_optimizer object. Return Value logical Returns true if a module is defined; else, false. procedure, public :: set_default_line_search => lso_set_default private  subroutine lso_set_default(this) Establishes a default line_search object for the line search\nmodule. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(inout) :: this The line_search_optimizer object. procedure, public :: set_line_search => lso_set_line_search private  subroutine lso_set_line_search(this, ls) Sets the line search module. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(inout) :: this The line_search_optimizer object. class( line_search ), intent(in) :: ls The line_search object. procedure, public :: set_max_fcn_evals => oe_set_max_eval private  subroutine oe_set_max_eval(this, n) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => oe_set_print_status private  subroutine oe_set_print_status(this, x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_tolerance => oe_set_tol private  subroutine oe_set_tol(this, x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. real(kind=real64), intent(in) :: x The tolerance. procedure, public :: set_use_line_search => lso_set_use_search private  subroutine lso_set_use_search(this, x) Sets a value determining if a line-search should be employed. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(inout) :: this The line_search_optimizer object. logical, intent(in) :: x Set to true if a line search should be used; else, false. procedure, public :: set_var_tolerance => lso_set_var_tol private  subroutine lso_set_var_tol(this, x) Sets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(inout) :: this The line_search_optimizer object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: solve => bfgs_solve private module subroutine bfgs_solve(this, fcn, x, fout, ib, err) Utilizes the Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm\nfor finding a minimum value of the specified function. Arguments Type Intent Optional Attributes Name class( bfgs ), intent(inout) :: this The bfgs object. class( fcnnvar_helper ), intent(in) :: fcn The fcnnvar_helper object containing the equation to \noptimize. real(kind=real64), intent(inout), dimension(:) :: x On input, the initial guess at the optimal point.  On output, \nthe updated optimal point estimate. real(kind=real64), intent(out), optional :: fout An optional output, that if provided, returns the value of the \nfunction at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\bfgs.html"},{"title":"line_search_optimizer – NONLIN ","text":"type, public, abstract, extends( equation_optimizer ) :: line_search_optimizer A class describing equation optimizers that use a line search\nalgorithm to improve convergence behavior. Contents Type-Bound Procedures get_line_search get_max_fcn_evals get_print_status get_tolerance get_use_line_search get_var_tolerance is_line_search_defined set_default_line_search set_line_search set_max_fcn_evals set_print_status set_tolerance set_use_line_search set_var_tolerance solve Type-Bound Procedures procedure, public :: get_line_search => lso_get_line_search private  subroutine lso_get_line_search(this, ls) Gets the line search module. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(in) :: this The line_search_optimizer object. class( line_search ), intent(out), allocatable :: ls The line_search object. procedure, public :: get_max_fcn_evals => oe_get_max_eval private pure function oe_get_max_eval(this) result(n) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => oe_get_print_status private pure function oe_get_print_status(this) result(x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_tolerance => oe_get_tol private pure function oe_get_tol(this) result(x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value real(kind=real64) The tolerance. procedure, public :: get_use_line_search => lso_get_use_search private pure function lso_get_use_search(this) result(x) Gets a value determining if a line-search should be employed. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(in) :: this The line_search_optimizer object. Return Value logical Returns true if a line search should be used; else, false. procedure, public :: get_var_tolerance => lso_get_var_tol private pure function lso_get_var_tol(this) result(x) Gets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(in) :: this The line_search_optimizer object. Return Value real(kind=real64) The tolerance value. procedure, public :: is_line_search_defined => lso_is_line_search_defined private pure function lso_is_line_search_defined(this) result(x) Tests to see if a line search module is defined. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(in) :: this The line_search_optimizer object. Return Value logical Returns true if a module is defined; else, false. procedure, public :: set_default_line_search => lso_set_default private  subroutine lso_set_default(this) Establishes a default line_search object for the line search\nmodule. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(inout) :: this The line_search_optimizer object. procedure, public :: set_line_search => lso_set_line_search private  subroutine lso_set_line_search(this, ls) Sets the line search module. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(inout) :: this The line_search_optimizer object. class( line_search ), intent(in) :: ls The line_search object. procedure, public :: set_max_fcn_evals => oe_set_max_eval private  subroutine oe_set_max_eval(this, n) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => oe_set_print_status private  subroutine oe_set_print_status(this, x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_tolerance => oe_set_tol private  subroutine oe_set_tol(this, x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. real(kind=real64), intent(in) :: x The tolerance. procedure, public :: set_use_line_search => lso_set_use_search private  subroutine lso_set_use_search(this, x) Sets a value determining if a line-search should be employed. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(inout) :: this The line_search_optimizer object. logical, intent(in) :: x Set to true if a line search should be used; else, false. procedure, public :: set_var_tolerance => lso_set_var_tol private  subroutine lso_set_var_tol(this, x) Sets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( line_search_optimizer ), intent(inout) :: this The line_search_optimizer object. real(kind=real64), intent(in) :: x The tolerance value. procedure( nonlin_optimize_fcn ), public, deferred, pass :: solve subroutine nonlin_optimize_fcn(this, fcn, x, fout, ib, err) Prototype Describes the interface of a routine for optimizing an\nequation of N variables. Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. class( fcnnvar_helper ), intent(in) :: fcn The fcnnvar_helper object containing the equation to\noptimize. real(kind=real64), intent(inout), dimension(:) :: x On input, the initial guess at the optimal point.  On \noutput, the updated optimal point estimate. real(kind=real64), intent(out), optional :: fout An optional output, that if provided, returns the value of \nthe function at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\line_search_optimizer.html"},{"title":"nelder_mead – NONLIN ","text":"type, public, extends( equation_optimizer ) :: nelder_mead Defines a solver based upon Nelder and Mead's simplex algorithm\nfor minimization of functions of multiple variables. Contents Type-Bound Procedures get_initial_size get_max_fcn_evals get_print_status get_simplex get_tolerance set_initial_size set_max_fcn_evals set_print_status set_simplex set_tolerance solve Type-Bound Procedures procedure, public :: get_initial_size => nm_get_size private pure function nm_get_size(this) result(x) Gets the size of the initial simplex that will be utilized by\nthe Nelder-Mead algorithm in the event that the user does not supply\na simplex geometry, or if the user supplies an invalid simplex\ngeometry. Arguments Type Intent Optional Attributes Name class( nelder_mead ), intent(in) :: this The nelder_mead object. Return Value real(kind=real64) The size of the simplex (length of an edge). procedure, public :: get_max_fcn_evals => oe_get_max_eval private pure function oe_get_max_eval(this) result(n) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => oe_get_print_status private pure function oe_get_print_status(this) result(x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_simplex => nm_get_simplex private pure function nm_get_simplex(this) result(p) Gets an N-by-(N+1) matrix containing the current simplex. Arguments Type Intent Optional Attributes Name class( nelder_mead ), intent(in) :: this The nelder_mead object. Return Value real(kind=real64), allocatable, dimension(:,:) The N-by-(N+1) matrix containing the simplex.  Each vertex of \nthe simplex is stored as its own column of this matrix. procedure, public :: get_tolerance => oe_get_tol private pure function oe_get_tol(this) result(x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(in) :: this The equation_optimizer object. Return Value real(kind=real64) The tolerance. procedure, public :: set_initial_size => nm_set_size private  subroutine nm_set_size(this, x) Sets the size of the initial simplex that will be utilized by\nthe Nelder-Mead algorithm in the event that the user does not supply\na simplex geometry, or if the user supplies an invalid simplex\ngeometry. Arguments Type Intent Optional Attributes Name class( nelder_mead ), intent(inout) :: this The nelder_mead object. real(kind=real64), intent(in) :: x The size of the simplex (length of an edge). procedure, public :: set_max_fcn_evals => oe_set_max_eval private  subroutine oe_set_max_eval(this, n) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => oe_set_print_status private  subroutine oe_set_print_status(this, x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_simplex => nm_set_simplex private  subroutine nm_set_simplex(this, x) Sets an N-by-(N+1) matrix as the current simplex.  Notice, if\nthis matrix is different in size from the problem dimensionallity,\nthe Nelder-Mead routine will replace it with an appropriately sized\nmatrix. Arguments Type Intent Optional Attributes Name class( nelder_mead ), intent(inout) :: this The nelder_mead object. real(kind=real64), dimension(:,:) :: x The simplex matrix.  Each column of the matrix must contain the\ncoordinates of each vertex of the simplex. procedure, public :: set_tolerance => oe_set_tol private  subroutine oe_set_tol(this, x) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. real(kind=real64), intent(in) :: x The tolerance. procedure, public :: solve => nm_solve private  subroutine nm_solve(this, fcn, x, fout, ib, err) Utilizes the Nelder-Mead simplex method for finding a minimum\nvalue of the specified function. The implementation of the Nelder-Mead algorithm presented here is a\nslight modification of the original work of Nelder and Mead.  The\nNumerical Recipes implementation is also quite similar.  In fact, the\nNumerical Recipes section relating to reflection, contraction, etc.\nis leveraged for this implemetation. See Also: Nelder, John A.; R. Mead (1965). \"A simplex method for function\n     minimization\". Computer Journal. 7: 308–313. [Gao, Fuchang, Han, Lixing (2010). \"Implementing the Nelder-Mead\n     simplex algorithm with adaptive parameters.\"]\n     (http://www.webpages.uidaho.edu/~fuchang/res/ANMS.pdf) Wikipedia Numerical Recipes Arguments Type Intent Optional Attributes Name class( nelder_mead ), intent(inout) :: this The nelder_mead object. class( fcnnvar_helper ), intent(in) :: fcn The fcnnvar_helper object containing the equation to \noptimize. real(kind=real64), intent(inout), dimension(:) :: x On input, the initial guess at the optimal point.  On output, \nthe updated optimal point estimate. real(kind=real64), intent(out), optional :: fout An optional output, that if provided, returns the value of the \nfunction at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\nelder_mead.html"},{"title":"polynomial – NONLIN ","text":"type, public :: polynomial Defines a polynomial, and associated routines for performing\npolynomial operations. Contents Type-Bound Procedures companion_mtx evaluate fit fit_thru_zero get get_all initialize order roots set Type-Bound Procedures procedure, public :: companion_mtx => poly_companion_mtx private pure function poly_companion_mtx(this) result(c) Returns the companion matrix for the polynomial. See Also Wikipedia Wolfram MathWorld Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: this The polynomial object. Return Value real(kind=real64), dimension(this%order(), this%order()) The companion matrix. generic, public :: evaluate => evaluate_real, evaluate_complex private elemental function poly_eval_double(this, x) result(y) Evaluates a polynomial at the specified points. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: this The polynomial object. real(kind=real64), intent(in) :: x The value(s) at which to evaluate the polynomial. Return Value real(kind=real64) The value(s) of the polynomial at x. private elemental function poly_eval_complex(this, x) result(y) Evaluates a polynomial at the specified points. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: this The polynomial object. complex(kind=real64), intent(in) :: x The value(s) at which to evaluate the polynomial. Return Value complex(kind=real64) The value(s) of the polynomial at x. procedure, public :: fit => poly_fit private  subroutine poly_fit(this, x, y, order, err) Fits a polynomial of the specified order to the supplied data set. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: this The polynomial object. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variable data\npoints.  Notice, must be N > order. real(kind=real64), intent(inout), dimension(:) :: y On input, an N-element array containing the dependent variable \ndata points.  On output, the contents are overwritten. integer(kind=int32), intent(in) :: order The order of the polynomial (must be >= 1). class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: fit_thru_zero => poly_fit_thru_zero private  subroutine poly_fit_thru_zero(this, x, y, order, err) Fits a polynomial of the specified order that passes through zero\nto the supplied data set. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: this The polynomial object. real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variable data\npoints.  Notice, must be N > order. real(kind=real64), intent(inout), dimension(:) :: y On input, an N-element array containing the dependent\nvariable data points.  On output, the contents are overwritten. integer(kind=int32), intent(in) :: order The order of the polynomial (must be >= 1). class(errors), intent(inout), optional, target :: err procedure, public :: get => get_poly_coefficient private  function get_poly_coefficient(this, ind, err) result(c) Gets the requested polynomial coefficient by index.  The\ncoefficient index is established as follows: c(1) + c(2) * x +\nc(3) * x 2 + ... c(n) * x n-1. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: this The polynomial object. integer(kind=int32), intent(in) :: ind The polynomial coefficient index. class(errors), intent(inout), optional, target :: err An error handling object. Return Value real(kind=real64) The requested coefficient. procedure, public :: get_all => get_poly_coefficients private pure function get_poly_coefficients(this) result(c) Gets an array containing all the coefficients of the polynomial.\nThe coefficient index is established as follows: c(1) + c(2) * x +\nc(3) * x 2 + ... c(n) * x n-1. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: this The polynomial object. Return Value real(kind=real64), dimension(this%order() + 1) The array of coefficients. generic, public :: initialize => init_poly, init_poly_coeffs private  subroutine init_poly(this, order, err) Initializes the polynomial instance. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: this The polynomial object. integer(kind=int32), intent(in) :: order The order of the polynomial (must be >= 0). class(errors), intent(inout), optional, target :: err An error handling object. private  subroutine init_poly_coeffs(this, c, err) Initializes the polynomial instance. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: this The polynomial object. real(kind=real64), intent(in), dimension(:) :: c The array of polynomial coefficients. The coefficients are\nestablished as follows: c(1) + c(2) * x + c(3) * x 2 + ...\nc(n) * x n-1. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: order => get_poly_order private pure function get_poly_order(this) result(n) Returns the order of the polynomial object. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: this The polynomial object. Return Value integer(kind=int32) The order of the polynomial.  Returns -1 in the event no\npolynomial coefficients have been defined. procedure, public :: roots => poly_roots private  function poly_roots(this, err) result(z) Computes all the roots of a polynomial by computing the eigenvalues\nof the polynomial companion matrix. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: this The polynomial object. class(errors), intent(inout), optional, target :: err An error handling object. Return Value complex(kind=real64), dimension(this%order()) The roots of the polynomial. procedure, public :: set => set_poly_coefficient private  subroutine set_poly_coefficient(this, ind, c, err) Sets the requested polynomial coefficient by index.  The\ncoefficient index is established as follows: c(1) + c(2) * x +\nc(3) * x 2 + ... c(n) * x n-1. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: this The polynomial object. integer(kind=int32), intent(in) :: ind The polynomial coefficient index. real(kind=real64), intent(in) :: c The polynomial coefficient. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\polynomial.html"},{"title":"equation_solver_1var – NONLIN ","text":"type, public, abstract :: equation_solver_1var A base class for various solvers of equations of one variable. Contents Type-Bound Procedures get_diff_tolerance get_fcn_tolerance get_max_fcn_evals get_print_status get_var_tolerance set_diff_tolerance set_fcn_tolerance set_max_fcn_evals set_print_status set_var_tolerance solve Type-Bound Procedures procedure, public :: get_diff_tolerance => es1_get_diff_tol private pure function es1_get_diff_tol(this) result(x) Gets the convergence on slope of the function (derivative)\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_fcn_tolerance => es1_get_fcn_tol private pure function es1_get_fcn_tol(this) result(x) Gets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_max_fcn_evals => es1_get_max_eval private pure function es1_get_max_eval(this) result(n) Gets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => es1_get_print_status private pure function es1_get_print_status(this) result(x) Gets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_var_tolerance => es1_get_var_tol private pure function es1_get_var_tol(this) result(x) Gets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value real(kind=real64) The tolerance value. procedure, public :: set_diff_tolerance => es1_set_diff_tol private  subroutine es1_set_diff_tol(this, x) Sets the convergence on slope of the function (derivative)\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_fcn_tolerance => es1_set_fcn_tol private  subroutine es1_set_fcn_tol(this, x) Sets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_max_fcn_evals => es1_set_max_eval private  subroutine es1_set_max_eval(this, n) Sets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => es1_set_print_status private  subroutine es1_set_print_status(this, x) Sets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_var_tolerance => es1_set_var_tol private  subroutine es1_set_var_tol(this, x) Sets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. real(kind=real64), intent(in) :: x The tolerance value. procedure( nonlin_solver_1var ), public, deferred, pass :: solve subroutine nonlin_solver_1var(this, fcn, x, lim, f, ib, err) Prototype Describes the interface of a solver for an equation of one\nvariable. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. class( fcn1var_helper ), intent(in) :: fcn The fcn1var_helper object containing the equation to solve. real(kind=real64), intent(inout) :: x On input the initial guess at the solution.  On output the \nsolution. type( value_pair ), intent(in) :: lim A value_pair object defining the search limits. real(kind=real64), intent(out), optional :: f An optional parameter used to return the function residual \nas computed at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the\ncaller to obtain iteration performance information. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\equation_solver_1var.html"},{"title":"fcn1var_helper – NONLIN ","text":"type, public :: fcn1var_helper Defines a type capable of encapsulating an equation of one\nvariable of the form: f(x) = 0. Contents Type-Bound Procedures diff fcn is_derivative_defined is_fcn_defined set_diff set_fcn Type-Bound Procedures procedure, public :: diff => f1h_diff_fcn private  function f1h_diff_fcn(this, x, f) result(df) Computes the derivative of the function.  If a routine for computing \nthe derivative is not defined, the derivative is estimated via \nfinite differences. Arguments Type Intent Optional Attributes Name class( fcn1var_helper ), intent(in) :: this The fcn1var_helper object. real(kind=real64), intent(in) :: x The value of the independent variable at which the derivative is \nto be computed. real(kind=real64), intent(in), optional :: f An optional input specifying the function value at x.  If \nsupplied, and the derivative is being estimated numerically, the \nfunction will not be evaluated at x. Return Value real(kind=real64) The value of the derivative. procedure, public :: fcn => f1h_fcn private  function f1h_fcn(this, x) result(f) Executes the routine containing the function to evaluate. Arguments Type Intent Optional Attributes Name class( fcn1var_helper ), intent(in) :: this The fcn1var_helper object. real(kind=real64), intent(in) :: x The value of the independent variable at which the function\nshould be evaluated. Return Value real(kind=real64) The value of the function. procedure, public :: is_derivative_defined => f1h_is_diff_defined private  function f1h_is_diff_defined(this) result(x) Tests if the pointer to the function containing the derivative of \nthe function to solve is defined. Arguments Type Intent Optional Attributes Name class( fcn1var_helper ), intent(in) :: this The fcn1var_helper object. Return Value logical Returns true if the pointer has been assigned; else, false. procedure, public :: is_fcn_defined => f1h_is_fcn_defined private  function f1h_is_fcn_defined(this) result(x) Tests if the pointer to the function containing the equation\nto solve has been assigned. Arguments Type Intent Optional Attributes Name class( fcn1var_helper ), intent(in) :: this The fcn1var_helper object. Return Value logical Returns true if the pointer has been assigned; else, false. procedure, public :: set_diff => f1h_set_diff private  subroutine f1h_set_diff(this, diff) Establishes a pointer to the routine containing the derivative of the\nequations to solve. Arguments Type Intent Optional Attributes Name class( fcn1var_helper ), intent(inout) :: this The fcn1var_helper object. procedure( fcn1var ), intent(in), pointer :: diff A pointer to the function for computing the first derivative. procedure, public :: set_fcn => f1h_set_fcn private  subroutine f1h_set_fcn(this, fcn) Establishes a pointer to the routine containing the equations\nto solve. Arguments Type Intent Optional Attributes Name class( fcn1var_helper ), intent(inout) :: this The fcn1var_helper object. procedure( fcn1var ), intent(in), pointer :: fcn The function pointer.","tags":"","loc":"type\\fcn1var_helper.html"},{"title":"brent_solver – NONLIN ","text":"type, public, extends( equation_solver_1var ) :: brent_solver Defines a solver based upon Brent's method for solving an equation\nof one variable without using derivatives. Contents Type-Bound Procedures get_diff_tolerance get_fcn_tolerance get_max_fcn_evals get_print_status get_var_tolerance set_diff_tolerance set_fcn_tolerance set_max_fcn_evals set_print_status set_var_tolerance solve Type-Bound Procedures procedure, public :: get_diff_tolerance => es1_get_diff_tol private pure function es1_get_diff_tol(this) result(x) Gets the convergence on slope of the function (derivative)\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_fcn_tolerance => es1_get_fcn_tol private pure function es1_get_fcn_tol(this) result(x) Gets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_max_fcn_evals => es1_get_max_eval private pure function es1_get_max_eval(this) result(n) Gets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => es1_get_print_status private pure function es1_get_print_status(this) result(x) Gets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_var_tolerance => es1_get_var_tol private pure function es1_get_var_tol(this) result(x) Gets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value real(kind=real64) The tolerance value. procedure, public :: set_diff_tolerance => es1_set_diff_tol private  subroutine es1_set_diff_tol(this, x) Sets the convergence on slope of the function (derivative)\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_fcn_tolerance => es1_set_fcn_tol private  subroutine es1_set_fcn_tol(this, x) Sets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_max_fcn_evals => es1_set_max_eval private  subroutine es1_set_max_eval(this, n) Sets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => es1_set_print_status private  subroutine es1_set_print_status(this, x) Sets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_var_tolerance => es1_set_var_tol private  subroutine es1_set_var_tol(this, x) Sets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: solve => brent_solve private  subroutine brent_solve(this, fcn, x, lim, f, ib, err) Solves an equation of one variable using Brent's method. See Also Wikipedia Numerical Recipes R.P. Brent, \"Algorithms for Minimization without Derivatives,\"\n     Dover Publications, January 2002. ISBN 0-486-41998-3.\n     Further information available here . Arguments Type Intent Optional Attributes Name class( brent_solver ), intent(inout) :: this The brent_solver object. class( fcn1var_helper ), intent(in) :: fcn The fcn1var_helper object containing the equation to solve. real(kind=real64), intent(inout) :: x A parameter used to return the solution.  Notice, any input \nvalue will be ignored as this routine relies upon the search \nlimits in lim to provide a starting point. type( value_pair ), intent(in) :: lim A value_pair object defining the search limits. real(kind=real64), intent(out), optional :: f An optional parameter used to return the function residual as \ncomputed at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\brent_solver.html"},{"title":"line_search_solver – NONLIN ","text":"type, public, abstract, extends( equation_solver ) :: line_search_solver A class describing nonlinear solvers that use a line search\nalgorithm to improve convergence behavior. Contents Type-Bound Procedures get_fcn_tolerance get_gradient_tolerance get_line_search get_max_fcn_evals get_print_status get_use_line_search get_var_tolerance is_line_search_defined set_default_line_search set_fcn_tolerance set_gradient_tolerance set_line_search set_max_fcn_evals set_print_status set_use_line_search set_var_tolerance solve Type-Bound Procedures procedure, public :: get_fcn_tolerance => es_get_fcn_tol private pure function es_get_fcn_tol(this) result(x) Gets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_gradient_tolerance => es_get_grad_tol private pure function es_get_grad_tol(this) result(x) Gets the convergence on slope of the gradient vector\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_line_search => lss_get_line_search private  subroutine lss_get_line_search(this, ls) Gets the line search module. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(in) :: this The line_search_solver object. class( line_search ), intent(out), allocatable :: ls The line_search object. procedure, public :: get_max_fcn_evals => es_get_max_eval private pure function es_get_max_eval(this) result(n) Gets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => es_get_print_status private pure function es_get_print_status(this) result(x) Gets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_use_line_search => lss_get_use_search private pure function lss_get_use_search(this) result(x) Gets a value determining if a line-search should be employed. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(in) :: this The line_search_solver object. Return Value logical Returns true if a line search should be used; else, false. procedure, public :: get_var_tolerance => es_get_var_tol private pure function es_get_var_tol(this) result(x) Gets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: is_line_search_defined => lss_is_line_search_defined private pure function lss_is_line_search_defined(this) result(x) Tests to see if a line search module is defined. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(in) :: this The line_search_solver object. Return Value logical Returns true if a module is defined; else, false. procedure, public :: set_default_line_search => lss_set_default private  subroutine lss_set_default(this) Establishes a default line_search object for the line search\nmodule. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(inout) :: this The line_search_solver object. procedure, public :: set_fcn_tolerance => es_set_fcn_tol private  subroutine es_set_fcn_tol(this, x) Sets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_gradient_tolerance => es_set_grad_tol private  subroutine es_set_grad_tol(this, x) Sets the convergence on slope of the gradient vector tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_line_search => lss_set_line_search private  subroutine lss_set_line_search(this, ls) Sets the line search module. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(inout) :: this The line_search_solver object. class( line_search ), intent(in) :: ls The line_search object. procedure, public :: set_max_fcn_evals => es_set_max_eval private  subroutine es_set_max_eval(this, n) Sets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => es_set_print_status private  subroutine es_set_print_status(this, x) Sets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_use_line_search => lss_set_use_search private  subroutine lss_set_use_search(this, x) Sets a value determining if a line-search should be employed. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(inout) :: this The line_search_solver object. logical, intent(in) :: x Set to true if a line search should be used; else, false. procedure, public :: set_var_tolerance => es_set_var_tol private  subroutine es_set_var_tol(this, x) Sets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure( nonlin_solver ), public, deferred, pass :: solve subroutine nonlin_solver(this, fcn, x, fvec, ib, err) Prototype Describes the interface of a nonlinear equation solver. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver -based object. class( vecfcn_helper ), intent(in) :: fcn The vecfcn_helper object containing the equations to\nsolve. real(kind=real64), intent(inout), dimension(:) :: x On input, an N-element array containing an initial estimate \nto the solution.  On output, the updated solution estimate.\nN is the number of variables. real(kind=real64), intent(out), dimension(:) :: fvec An M-element array that, on output, will contain the values \nof each equation as evaluated at the variable values given \nin x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\line_search_solver.html"},{"title":"newton_1var_solver – NONLIN ","text":"type, public, extends( equation_solver_1var ) :: newton_1var_solver Defines a solver based upon Newtons's method for solving an\nequation of one variable.  The algorithm uses a bisection method in\nconjunction with Newton's method in order to keep bounds upon the\nNewton iterations. Contents Type-Bound Procedures get_diff_tolerance get_fcn_tolerance get_max_fcn_evals get_print_status get_var_tolerance set_diff_tolerance set_fcn_tolerance set_max_fcn_evals set_print_status set_var_tolerance solve Type-Bound Procedures procedure, public :: get_diff_tolerance => es1_get_diff_tol private pure function es1_get_diff_tol(this) result(x) Gets the convergence on slope of the function (derivative)\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_fcn_tolerance => es1_get_fcn_tol private pure function es1_get_fcn_tol(this) result(x) Gets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_max_fcn_evals => es1_get_max_eval private pure function es1_get_max_eval(this) result(n) Gets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => es1_get_print_status private pure function es1_get_print_status(this) result(x) Gets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_var_tolerance => es1_get_var_tol private pure function es1_get_var_tol(this) result(x) Gets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(in) :: this The equation_solver_1var object. Return Value real(kind=real64) The tolerance value. procedure, public :: set_diff_tolerance => es1_set_diff_tol private  subroutine es1_set_diff_tol(this, x) Sets the convergence on slope of the function (derivative)\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_fcn_tolerance => es1_set_fcn_tol private  subroutine es1_set_fcn_tol(this, x) Sets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_max_fcn_evals => es1_set_max_eval private  subroutine es1_set_max_eval(this, n) Sets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => es1_set_print_status private  subroutine es1_set_print_status(this, x) Sets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_var_tolerance => es1_set_var_tol private  subroutine es1_set_var_tol(this, x) Sets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: solve => newt1var_solve private  subroutine newt1var_solve(this, fcn, x, lim, f, ib, err) Solves an equation of one variable using Newton's method. Arguments Type Intent Optional Attributes Name class( newton_1var_solver ), intent(inout) :: this The newton_1var_solver object. class( fcn1var_helper ), intent(in) :: fcn The fcn1var_helper object containing the equation to solve. real(kind=real64), intent(inout) :: x A parameter used to return the solution.  Notice, any input \nvalue will be ignored as this routine relies upon the search \nlimits in lim to provide a starting point. type( value_pair ), intent(in) :: lim A value_pair object defining the search limits. real(kind=real64), intent(out), optional :: f An optional parameter used to return the function residual as \ncomputed at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\newton_1var_solver.html"},{"title":"newton_solver – NONLIN ","text":"type, public, extends( line_search_solver ) :: newton_solver Defines a Newton solver. Contents Type-Bound Procedures get_fcn_tolerance get_gradient_tolerance get_line_search get_max_fcn_evals get_print_status get_use_line_search get_var_tolerance is_line_search_defined set_default_line_search set_fcn_tolerance set_gradient_tolerance set_line_search set_max_fcn_evals set_print_status set_use_line_search set_var_tolerance solve Type-Bound Procedures procedure, public :: get_fcn_tolerance => es_get_fcn_tol private pure function es_get_fcn_tol(this) result(x) Gets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_gradient_tolerance => es_get_grad_tol private pure function es_get_grad_tol(this) result(x) Gets the convergence on slope of the gradient vector\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_line_search => lss_get_line_search private  subroutine lss_get_line_search(this, ls) Gets the line search module. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(in) :: this The line_search_solver object. class( line_search ), intent(out), allocatable :: ls The line_search object. procedure, public :: get_max_fcn_evals => es_get_max_eval private pure function es_get_max_eval(this) result(n) Gets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => es_get_print_status private pure function es_get_print_status(this) result(x) Gets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_use_line_search => lss_get_use_search private pure function lss_get_use_search(this) result(x) Gets a value determining if a line-search should be employed. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(in) :: this The line_search_solver object. Return Value logical Returns true if a line search should be used; else, false. procedure, public :: get_var_tolerance => es_get_var_tol private pure function es_get_var_tol(this) result(x) Gets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: is_line_search_defined => lss_is_line_search_defined private pure function lss_is_line_search_defined(this) result(x) Tests to see if a line search module is defined. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(in) :: this The line_search_solver object. Return Value logical Returns true if a module is defined; else, false. procedure, public :: set_default_line_search => lss_set_default private  subroutine lss_set_default(this) Establishes a default line_search object for the line search\nmodule. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(inout) :: this The line_search_solver object. procedure, public :: set_fcn_tolerance => es_set_fcn_tol private  subroutine es_set_fcn_tol(this, x) Sets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_gradient_tolerance => es_set_grad_tol private  subroutine es_set_grad_tol(this, x) Sets the convergence on slope of the gradient vector tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_line_search => lss_set_line_search private  subroutine lss_set_line_search(this, ls) Sets the line search module. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(inout) :: this The line_search_solver object. class( line_search ), intent(in) :: ls The line_search object. procedure, public :: set_max_fcn_evals => es_set_max_eval private  subroutine es_set_max_eval(this, n) Sets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => es_set_print_status private  subroutine es_set_print_status(this, x) Sets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_use_line_search => lss_set_use_search private  subroutine lss_set_use_search(this, x) Sets a value determining if a line-search should be employed. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(inout) :: this The line_search_solver object. logical, intent(in) :: x Set to true if a line search should be used; else, false. procedure, public :: set_var_tolerance => es_set_var_tol private  subroutine es_set_var_tol(this, x) Sets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: solve => ns_solve private  subroutine ns_solve(this, fcn, x, fvec, ib, err) Applies Newton's method in conjunction with a backtracking type\nline search to solve N equations of N unknowns. Arguments Type Intent Optional Attributes Name class( newton_solver ), intent(inout) :: this The newton_solver object. class( vecfcn_helper ), intent(in) :: fcn The vecfcn_helper object containing the equations to solve. real(kind=real64), intent(inout), dimension(:) :: x On input, an N-element array containing an initial estimate to \nthe solution.  On output, the updated solution estimate.  N is \nthe number of variables. real(kind=real64), intent(out), dimension(:) :: fvec An N-element array that, on output, will contain the values of \neach equation as evaluated at the variable values given in x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error-handling object.","tags":"","loc":"type\\newton_solver.html"},{"title":"quasi_newton_solver – NONLIN ","text":"type, public, extends( line_search_solver ) :: quasi_newton_solver Defines a quasi-Newton type solver based upon Broyden's method. Contents Type-Bound Procedures get_fcn_tolerance get_gradient_tolerance get_jacobian_interval get_line_search get_max_fcn_evals get_print_status get_use_line_search get_var_tolerance is_line_search_defined set_default_line_search set_fcn_tolerance set_gradient_tolerance set_jacobian_interval set_line_search set_max_fcn_evals set_print_status set_use_line_search set_var_tolerance solve Type-Bound Procedures procedure, public :: get_fcn_tolerance => es_get_fcn_tol private pure function es_get_fcn_tol(this) result(x) Gets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_gradient_tolerance => es_get_grad_tol private pure function es_get_grad_tol(this) result(x) Gets the convergence on slope of the gradient vector\ntolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: get_jacobian_interval => qns_get_jac_interval private pure function qns_get_jac_interval(this) result(n) Gets the number of iterations that may pass before forcing a\nrecalculation of the Jacobian matrix. Arguments Type Intent Optional Attributes Name class( quasi_newton_solver ), intent(in) :: this The quasi_newton_solver object. Return Value integer(kind=int32) The number of iterations. procedure, public :: get_line_search => lss_get_line_search private  subroutine lss_get_line_search(this, ls) Gets the line search module. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(in) :: this The line_search_solver object. class( line_search ), intent(out), allocatable :: ls The line_search object. procedure, public :: get_max_fcn_evals => es_get_max_eval private pure function es_get_max_eval(this) result(n) Gets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value integer(kind=int32) The maximum number of function evaluations. procedure, public :: get_print_status => es_get_print_status private pure function es_get_print_status(this) result(x) Gets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value logical True if the iteration status should be printed; else, false. procedure, public :: get_use_line_search => lss_get_use_search private pure function lss_get_use_search(this) result(x) Gets a value determining if a line-search should be employed. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(in) :: this The line_search_solver object. Return Value logical Returns true if a line search should be used; else, false. procedure, public :: get_var_tolerance => es_get_var_tol private pure function es_get_var_tol(this) result(x) Gets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(in) :: this The equation_solver object. Return Value real(kind=real64) The tolerance value. procedure, public :: is_line_search_defined => lss_is_line_search_defined private pure function lss_is_line_search_defined(this) result(x) Tests to see if a line search module is defined. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(in) :: this The line_search_solver object. Return Value logical Returns true if a module is defined; else, false. procedure, public :: set_default_line_search => lss_set_default private  subroutine lss_set_default(this) Establishes a default line_search object for the line search\nmodule. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(inout) :: this The line_search_solver object. procedure, public :: set_fcn_tolerance => es_set_fcn_tol private  subroutine es_set_fcn_tol(this, x) Sets the convergence on function value tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_gradient_tolerance => es_set_grad_tol private  subroutine es_set_grad_tol(this, x) Sets the convergence on slope of the gradient vector tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: set_jacobian_interval => qns_set_jac_interval private  subroutine qns_set_jac_interval(this, n) Sets the number of iterations that may pass before forcing a\nrecalculation of the Jacobian matrix. Arguments Type Intent Optional Attributes Name class( quasi_newton_solver ), intent(inout) :: this The quasi_newton_solver object. integer(kind=int32), intent(in) :: n The number of iterations. procedure, public :: set_line_search => lss_set_line_search private  subroutine lss_set_line_search(this, ls) Sets the line search module. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(inout) :: this The line_search_solver object. class( line_search ), intent(in) :: ls The line_search object. procedure, public :: set_max_fcn_evals => es_set_max_eval private  subroutine es_set_max_eval(this, n) Sets the maximum number of function evaluations allowed during\na single solve. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. integer(kind=int32), intent(in) :: n The maximum number of function evaluations. procedure, public :: set_print_status => es_set_print_status private  subroutine es_set_print_status(this, x) Sets a logical value determining if iteration status should be\nprinted. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. logical, intent(in) :: x True if the iteration status should be printed; else, false. procedure, public :: set_use_line_search => lss_set_use_search private  subroutine lss_set_use_search(this, x) Sets a value determining if a line-search should be employed. Arguments Type Intent Optional Attributes Name class( line_search_solver ), intent(inout) :: this The line_search_solver object. logical, intent(in) :: x Set to true if a line search should be used; else, false. procedure, public :: set_var_tolerance => es_set_var_tol private  subroutine es_set_var_tol(this, x) Sets the convergence on change in variable tolerance. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver object. real(kind=real64), intent(in) :: x The tolerance value. procedure, public :: solve => qns_solve private  subroutine qns_solve(this, fcn, x, fvec, ib, err) Applies the quasi-Newton's method developed by Broyden in \nconjunction with a backtracking type line search to solve N equations\nof N unknowns. See Also: Broyden's Paper Wikipedia Numerical Recipes Arguments Type Intent Optional Attributes Name class( quasi_newton_solver ), intent(inout) :: this The quasi_newton_solver object. class( vecfcn_helper ), intent(in) :: fcn The vecfcn_helper object containing the equations to solve. real(kind=real64), intent(inout), dimension(:) :: x On input, an N-element array containing an initial estimate to \nthe solution.  On output, the updated solution estimate.  N is \nthe number of variables. real(kind=real64), intent(out), dimension(:) :: fvec An N-element array that, on output, will contain the values of \neach equation as evaluated at the variable values given in x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"type\\quasi_newton_solver.html"},{"title":"iteration_behavior – NONLIN ","text":"type, public :: iteration_behavior Defines a set of parameters that describe the behavior of the\niteration process. Contents Variables converge_on_chng converge_on_fcn converge_on_zero_diff fcn_count gradient_count iter_count jacobian_count Components Type Visibility Attributes Name Initial logical, public :: converge_on_chng True if the solution converged as a result of no appreciable\nchange in solution points between iterations; else, false. logical, public :: converge_on_fcn True if the solution converged as a result of a zero-valued\nfunction; else, false. logical, public :: converge_on_zero_diff True if the solution appears to have settled on a stationary\npoint such that the gradient of the function is zero-valued; \nelse, false. integer(kind=int32), public :: fcn_count Specifies the number of function evaluations performed. integer(kind=int32), public :: gradient_count Specifies the number of gradient vector evaluations performed. integer(kind=int32), public :: iter_count Specifies the number of iterations performed. integer(kind=int32), public :: jacobian_count Specifies the number of Jacobian evaluations performed.","tags":"","loc":"type\\iteration_behavior.html"},{"title":"value_pair – NONLIN ","text":"type, public :: value_pair Defines a pair of numeric values. Contents Variables x1 x2 Components Type Visibility Attributes Name Initial real(kind=real64), public :: x1 Value 1. real(kind=real64), public :: x2 Value 2.","tags":"","loc":"type\\value_pair.html"},{"title":"print_status – NONLIN","text":"public  subroutine print_status(iter, nfeval, njaceval, xnorm, fnorm) @brief Prints the iteration status. @param[in] iter The iteration number.\n@param[in] nfeval The number of function evaluations.\n@param[in] njaceval The number of Jacobian evaluations.\n@param[in] xnorm The change in variable value.\n@param[in] fnorm The residual. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter integer(kind=int32), intent(in) :: nfeval integer(kind=int32), intent(in) :: njaceval real(kind=real64), intent(in) :: xnorm real(kind=real64), intent(in) :: fnorm Contents","tags":"","loc":"proc\\print_status.html"},{"title":"test_convergence – NONLIN","text":"public  subroutine test_convergence(x, xo, f, g, lg, xtol, ftol, gtol, c, cx, cf, cg, xnorm, fnorm) Tests for convergence. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The current solution estimate. real(kind=real64), intent(in), dimension(:) :: xo The previous solution estimate. real(kind=real64), intent(in), dimension(:) :: f The current residual based upon x. real(kind=real64), intent(in), dimension(:) :: g The current estimate of the gradient vector at x. logical, intent(in) :: lg Set to true if the gradient slope check should be performed; \nelse, false. real(kind=real64), intent(in) :: xtol The tolerance on the change in variable. real(kind=real64), intent(in) :: ftol The tolerance on the residual. real(kind=real64), intent(in) :: gtol The tolerance on the slope of the gradient. logical, intent(out) :: c True if the solution converged on either the residual or\nchange in variable. logical, intent(out) :: cx True if convergence occurred due to change in variable. logical, intent(out) :: cf True if convergence occurred due to residual. logical, intent(out) :: cg True if convergence occured due to slope of the gradient. real(kind=real64), intent(out) :: xnorm The largest magnitude component of the scaled change in variable \nvector. real(kind=real64), intent(out) :: fnorm The largest magnitude residual component. Contents","tags":"","loc":"proc\\test_convergence.html"},{"title":"limit_search_vector – NONLIN","text":"public  subroutine limit_search_vector(x, lim) Provides a means of scaling the length of the search direction\nvector. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the search direction vector.  On output, the search \ndirection vector limited in length to that specified by lim.\n If the vector is originally shorter than the limit length, no \nchange is made. real(kind=real64), intent(in) :: lim The length limit value. Contents","tags":"","loc":"proc\\limit_search_vector.html"},{"title":"jacobianfcn – NONLIN","text":"interface public  subroutine jacobianfcn(x, jac) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variables. real(kind=real64), intent(out), dimension(:,:) :: jac An M-by-N matrix where the Jacobian will be written. Description Describes a routine capable of computing the Jacobian matrix\nof M functions of N unknowns.","tags":"","loc":"interface\\jacobianfcn.html"},{"title":"nonlin_solver – NONLIN","text":"interface public  subroutine nonlin_solver(this, fcn, x, fvec, ib, err) Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver -based object. class( vecfcn_helper ), intent(in) :: fcn The vecfcn_helper object containing the equations to\nsolve. real(kind=real64), intent(inout), dimension(:) :: x On input, an N-element array containing an initial estimate \nto the solution.  On output, the updated solution estimate.\nN is the number of variables. real(kind=real64), intent(out), dimension(:) :: fvec An M-element array that, on output, will contain the values \nof each equation as evaluated at the variable values given \nin x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object. Description Describes the interface of a nonlinear equation solver.","tags":"","loc":"interface\\nonlin_solver.html"},{"title":"vecfcn – NONLIN","text":"interface public  subroutine vecfcn(x, f) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variables. real(kind=real64), intent(out), dimension(:) :: f An M-element array that, on output, contains the values\nof the M functions. Description Describes an M-element vector-valued function of N-variables.","tags":"","loc":"interface\\vecfcn.html"},{"title":"fcnnvar – NONLIN","text":"interface public  function fcnnvar(x) result(f) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variables. Return Value real(kind=real64) The value of the function. Description Describes a function of N variables.","tags":"","loc":"interface\\fcnnvar.html"},{"title":"gradientfcn – NONLIN","text":"interface public  subroutine gradientfcn(x, g) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variables. real(kind=real64), intent(out), dimension(:) :: g An N-element array where the gradient vector will be\nwritten as output. Description Describes a routine capable of computing the gradient vector\nof an equation of N variables.","tags":"","loc":"interface\\gradientfcn.html"},{"title":"nonlin_optimize_fcn – NONLIN","text":"interface public  subroutine nonlin_optimize_fcn(this, fcn, x, fout, ib, err) Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. class( fcnnvar_helper ), intent(in) :: fcn The fcnnvar_helper object containing the equation to\noptimize. real(kind=real64), intent(inout), dimension(:) :: x On input, the initial guess at the optimal point.  On \noutput, the updated optimal point estimate. real(kind=real64), intent(out), optional :: fout An optional output, that if provided, returns the value of \nthe function at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object. Description Describes the interface of a routine for optimizing an\nequation of N variables.","tags":"","loc":"interface\\nonlin_optimize_fcn.html"},{"title":"assignment(=) – NONLIN","text":"public interface assignment(=) Defines polynomial assignment. Contents Module Procedures poly_equals poly_dbl_equals poly_equals_array Module Procedures private  subroutine poly_equals(x, y) Assigns the contents of one polynomial to another. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: x The assignee. class( polynomial ), intent(in) :: y The item to copy. private  subroutine poly_dbl_equals(x, y) Assigns a number to each coefficient of the polynomial. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: x The assignee. real(kind=real64), intent(in) :: y The value to assign. private  subroutine poly_equals_array(x, y) Assigns the contents of an array as polynomial coefficients. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: x The assignee. real(kind=real64), intent(in), dimension(:) :: y The coefficient array.","tags":"","loc":"interface\\assignment(=).html"},{"title":"operator(*) – NONLIN","text":"public interface operator(*) Defines polynomial multiplication Contents Module Procedures poly_poly_mult poly_dbl_mult dbl_poly_mult Module Procedures private  function poly_poly_mult(x, y) result(z) Multiplies two polynomials. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: x The left-hand-side argument. class( polynomial ), intent(in) :: y The right-hand-side argument. Return Value type( polynomial ) The resulting polynomial. private  function poly_dbl_mult(x, y) result(z) Multiplies a polynomial by a scalar value. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: x The left-hand-side argument. real(kind=real64), intent(in) :: y The right-hand-side argument. Return Value type( polynomial ) The resulting polynomial. private  function dbl_poly_mult(x, y) result(z) Multiplies a polynomial by a scalar value. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The left-hand-side argument. class( polynomial ), intent(in) :: y The right-hand-side argument. Return Value type( polynomial ) The resulting polynomial.","tags":"","loc":"interface\\operator(ASTERISK).html"},{"title":"operator(+) – NONLIN","text":"public interface operator(+) Defines polynomial addition. Contents Module Procedures poly_poly_add Module Procedures private  function poly_poly_add(x, y) result(z) Adds two polynomials. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: x The left-hand-side argument. class( polynomial ), intent(in) :: y The right-hand-side argument. Return Value type( polynomial ) The resulting polynomial.","tags":"","loc":"interface\\operator(+).html"},{"title":"operator(-) – NONLIN","text":"public interface operator(-) Defines polynomial subtraction. Contents Module Procedures poly_poly_subtract Module Procedures private  function poly_poly_subtract(x, y) result(z) Subtracts two polynomials. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: x The left-hand-side argument. class( polynomial ), intent(in) :: y The right-hand-side argument. Return Value type( polynomial ) The resulting polynomial.","tags":"","loc":"interface\\operator(-).html"},{"title":"fcn1var – NONLIN","text":"interface public  function fcn1var(x) result(f) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The independent variable. Return Value real(kind=real64) The value of the function at x. Description Describes a function of one variable.","tags":"","loc":"interface\\fcn1var.html"},{"title":"nonlin_solver_1var – NONLIN","text":"interface public  subroutine nonlin_solver_1var(this, fcn, x, lim, f, ib, err) Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. class( fcn1var_helper ), intent(in) :: fcn The fcn1var_helper object containing the equation to solve. real(kind=real64), intent(inout) :: x On input the initial guess at the solution.  On output the \nsolution. type( value_pair ), intent(in) :: lim A value_pair object defining the search limits. real(kind=real64), intent(out), optional :: f An optional parameter used to return the function residual \nas computed at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the\ncaller to obtain iteration performance information. class(errors), intent(inout), optional, target :: err An error handling object. Description Describes the interface of a solver for an equation of one\nvariable.","tags":"","loc":"interface\\nonlin_solver_1var.html"},{"title":"nonlin – NONLIN","text":"Uses nonlin_optimize nonlin_types nonlin_single_var nonlin_solve nonlin_multi_eqn_mult_var nonlin_polynomials nonlin_linesearch nonlin_least_squares nonlin_multi_var Contents None","tags":"","loc":"module\\nonlin.html"},{"title":"nonlin_error_handling – NONLIN","text":"Uses linalg_errors iso_fortran_env Contents Variables NL_ARRAY_SIZE_ERROR NL_CONVERGENCE_ERROR NL_DIVERGENT_BEHAVIOR_ERROR NL_INVALID_INPUT_ERROR NL_INVALID_OPERATION_ERROR NL_NO_ERROR NL_OUT_OF_MEMORY_ERROR NL_SPURIOUS_CONVERGENCE_ERROR NL_TOLERANCE_TOO_SMALL_ERROR Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: NL_ARRAY_SIZE_ERROR = 202 An error flag denoting an improperly sized array. integer(kind=int32), public, parameter :: NL_CONVERGENCE_ERROR = LA_CONVERGENCE_ERROR An error resulting from a lack of convergence. integer(kind=int32), public, parameter :: NL_DIVERGENT_BEHAVIOR_ERROR = 206 An error resulting from a divergent condition. integer(kind=int32), public, parameter :: NL_INVALID_INPUT_ERROR = 201 An error flag denoting an invalid input. integer(kind=int32), public, parameter :: NL_INVALID_OPERATION_ERROR = LA_INVALID_OPERATION_ERROR An error resulting from an invalid operation. integer(kind=int32), public, parameter :: NL_NO_ERROR = 0 A flag denoting no error. integer(kind=int32), public, parameter :: NL_OUT_OF_MEMORY_ERROR = LA_OUT_OF_MEMORY_ERROR An error denoting that there is insufficient memory available. integer(kind=int32), public, parameter :: NL_SPURIOUS_CONVERGENCE_ERROR = 207 An error indicating a possible spurious convergence condition. integer(kind=int32), public, parameter :: NL_TOLERANCE_TOO_SMALL_ERROR = 208 An error indicating the user-requested tolerance is too small to be\npractical for the problem at hand.","tags":"","loc":"module\\nonlin_error_handling.html"},{"title":"nonlin_helper – NONLIN","text":"Uses iso_fortran_env Contents Subroutines print_status test_convergence Subroutines public  subroutine print_status (iter, nfeval, njaceval, xnorm, fnorm) @brief Prints the iteration status. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter integer(kind=int32), intent(in) :: nfeval integer(kind=int32), intent(in) :: njaceval real(kind=real64), intent(in) :: xnorm real(kind=real64), intent(in) :: fnorm public  subroutine test_convergence (x, xo, f, g, lg, xtol, ftol, gtol, c, cx, cf, cg, xnorm, fnorm) Tests for convergence. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The current solution estimate. real(kind=real64), intent(in), dimension(:) :: xo The previous solution estimate. real(kind=real64), intent(in), dimension(:) :: f The current residual based upon x. real(kind=real64), intent(in), dimension(:) :: g The current estimate of the gradient vector at x. logical, intent(in) :: lg Set to true if the gradient slope check should be performed; \nelse, false. real(kind=real64), intent(in) :: xtol The tolerance on the change in variable. real(kind=real64), intent(in) :: ftol The tolerance on the residual. real(kind=real64), intent(in) :: gtol The tolerance on the slope of the gradient. logical, intent(out) :: c True if the solution converged on either the residual or\nchange in variable. logical, intent(out) :: cx True if convergence occurred due to change in variable. logical, intent(out) :: cf True if convergence occurred due to residual. logical, intent(out) :: cg True if convergence occured due to slope of the gradient. real(kind=real64), intent(out) :: xnorm The largest magnitude component of the scaled change in variable \nvector. real(kind=real64), intent(out) :: fnorm The largest magnitude residual component.","tags":"","loc":"module\\nonlin_helper.html"},{"title":"nonlin_least_squares – NONLIN","text":"Uses nonlin_types nonlin_multi_eqn_mult_var ferror nonlin_error_handling iso_fortran_env nonlin_helper Contents Derived Types least_squares_solver Derived Types type, public, extends( equation_solver ) :: least_squares_solver @brief Defines a Levenberg-Marquardt based solver for unconstrained\nleast-squares problems.\nDefines a Levenberg-Marquardt based solver for unconstrained\nleast-squares problems. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_fcn_tolerance =>\n                    es_get_fcn_tol Function procedure\n                    ,                  public\n                  :: get_gradient_tolerance =>\n                    es_get_grad_tol Function procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    es_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    es_get_print_status Function procedure\n                    ,                  public\n                  :: get_step_scaling_factor =>\n                    lss_get_factor Function procedure\n                    ,                  public\n                  :: get_var_tolerance =>\n                    es_get_var_tol Function procedure\n                    ,                  public\n                  :: set_fcn_tolerance =>\n                    es_set_fcn_tol Subroutine procedure\n                    ,                  public\n                  :: set_gradient_tolerance =>\n                    es_set_grad_tol Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    es_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    es_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_step_scaling_factor =>\n                    lss_set_factor Subroutine procedure\n                    ,                  public\n                  :: set_var_tolerance =>\n                    es_set_var_tol Subroutine procedure\n                    ,                  public\n                  :: solve =>\n                    lss_solve Subroutine","tags":"","loc":"module\\nonlin_least_squares.html"},{"title":"nonlin_linesearch – NONLIN","text":"Uses nonlin_types nonlin_multi_eqn_mult_var ferror nonlin_error_handling iso_fortran_env nonlin_multi_var Contents Derived Types line_search Subroutines limit_search_vector Derived Types type, public :: line_search Defines a type capable of performing an inexact, backtracking line\nsearch to find a point as far along the specified direction vector \nthat is usable for unconstrained minimization problems. Read more… Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_distance_factor =>\n                    ls_get_dist Function procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    ls_get_max_eval Function procedure\n                    ,                  public\n                  :: get_scaling_factor =>\n                    ls_get_scale Function procedure\n                    ,                  public\n,                   :: ls_search_mimo Subroutine procedure\n                    ,                  public\n,                   :: ls_search_miso Subroutine generic,\n                  public\n                  :: search => ls_search_mimo , ls_search_miso procedure\n                    ,                  public\n                  :: set_distance_factor =>\n                    ls_set_dist Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    ls_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_scaling_factor =>\n                    ls_set_scale Subroutine Subroutines public  subroutine limit_search_vector (x, lim) Provides a means of scaling the length of the search direction\nvector. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x On input, the search direction vector.  On output, the search \ndirection vector limited in length to that specified by lim.\n If the vector is originally shorter than the limit length, no \nchange is made. real(kind=real64), intent(in) :: lim The length limit value.","tags":"","loc":"module\\nonlin_linesearch.html"},{"title":"nonlin_multi_eqn_mult_var – NONLIN","text":"Uses ferror iso_fortran_env nonlin_types Contents Interfaces jacobianfcn nonlin_solver vecfcn Derived Types equation_solver vecfcn_helper Interfaces interface public  subroutine jacobianfcn(x, jac) Describes a routine capable of computing the Jacobian matrix\nof M functions of N unknowns. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variables. real(kind=real64), intent(out), dimension(:,:) :: jac An M-by-N matrix where the Jacobian will be written. interface public  subroutine nonlin_solver(this, fcn, x, fvec, ib, err) Describes the interface of a nonlinear equation solver. Arguments Type Intent Optional Attributes Name class( equation_solver ), intent(inout) :: this The equation_solver -based object. class( vecfcn_helper ), intent(in) :: fcn The vecfcn_helper object containing the equations to\nsolve. real(kind=real64), intent(inout), dimension(:) :: x On input, an N-element array containing an initial estimate \nto the solution.  On output, the updated solution estimate.\nN is the number of variables. real(kind=real64), intent(out), dimension(:) :: fvec An M-element array that, on output, will contain the values \nof each equation as evaluated at the variable values given \nin x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object. interface public  subroutine vecfcn(x, f) Describes an M-element vector-valued function of N-variables. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variables. real(kind=real64), intent(out), dimension(:) :: f An M-element array that, on output, contains the values\nof the M functions. Derived Types type, public :: equation_solver A base class for various solvers of nonlinear systems of equations. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_fcn_tolerance =>\n                    es_get_fcn_tol Function procedure\n                    ,                  public\n                  :: get_gradient_tolerance =>\n                    es_get_grad_tol Function procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    es_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    es_get_print_status Function procedure\n                    ,                  public\n                  :: get_var_tolerance =>\n                    es_get_var_tol Function procedure\n                    ,                  public\n                  :: set_fcn_tolerance =>\n                    es_set_fcn_tol Subroutine procedure\n                    ,                  public\n                  :: set_gradient_tolerance =>\n                    es_set_grad_tol Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    es_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    es_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_var_tolerance =>\n                    es_set_var_tol Subroutine procedure\n(nonlin_solver)                    ,                  public\n, pass                  :: solve type, public :: vecfcn_helper Defines a type capable of encapsulating a system of nonlinear\nequations of the form: F(X) = 0.  This type is used to establish the\nsystem of equations to solve, and provides a means for computing\nthe Jacobian matrix for the system of equations, and any other\nancillary operations that may be needed by the solver. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: m_nvar = 0 The number of variables in m_fcn. Type-Bound Procedures procedure\n                    ,                  public\n                  :: fcn =>\n                    vfh_fcn Subroutine procedure\n                    ,                  public\n                  :: get_equation_count =>\n                    vfh_get_nfcn Function procedure\n                    ,                  public\n                  :: get_variable_count =>\n                    vfh_get_nvar Function procedure\n                    ,                  public\n                  :: is_fcn_defined =>\n                    vfh_is_fcn_defined Function procedure\n                    ,                  public\n                  :: is_jacobian_defined =>\n                    vfh_is_jac_defined Function procedure\n                    ,                  public\n                  :: jacobian =>\n                    vfh_jac_fcn Subroutine procedure\n                    ,                  public\n                  :: set_fcn =>\n                    vfh_set_fcn Subroutine procedure\n                    ,                  public\n                  :: set_jacobian =>\n                    vfh_set_jac Subroutine","tags":"","loc":"module\\nonlin_multi_eqn_mult_var.html"},{"title":"nonlin_multi_var – NONLIN","text":"Uses ferror iso_fortran_env nonlin_types Contents Interfaces fcnnvar gradientfcn nonlin_optimize_fcn Derived Types equation_optimizer fcnnvar_helper Interfaces interface public  function fcnnvar(x) result(f) Describes a function of N variables. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variables. Return Value real(kind=real64) The value of the function. interface public  subroutine gradientfcn(x, g) Describes a routine capable of computing the gradient vector\nof an equation of N variables. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variables. real(kind=real64), intent(out), dimension(:) :: g An N-element array where the gradient vector will be\nwritten as output. interface public  subroutine nonlin_optimize_fcn(this, fcn, x, fout, ib, err) Describes the interface of a routine for optimizing an\nequation of N variables. Arguments Type Intent Optional Attributes Name class( equation_optimizer ), intent(inout) :: this The equation_optimizer object. class( fcnnvar_helper ), intent(in) :: fcn The fcnnvar_helper object containing the equation to\noptimize. real(kind=real64), intent(inout), dimension(:) :: x On input, the initial guess at the optimal point.  On \noutput, the updated optimal point estimate. real(kind=real64), intent(out), optional :: fout An optional output, that if provided, returns the value of \nthe function at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the caller to \nobtain iteration performance statistics. class(errors), intent(inout), optional, target :: err An error handling object. Derived Types type, public :: equation_optimizer A base class for optimization of an equation of multiple variables. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    oe_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    oe_get_print_status Function procedure\n                    ,                  public\n                  :: get_tolerance =>\n                    oe_get_tol Function procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    oe_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    oe_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_tolerance =>\n                    oe_set_tol Subroutine procedure\n(nonlin_optimize_fcn)                    ,                  public\n, pass                  :: solve type, public :: fcnnvar_helper Defines a type capable of encapsulating an equation of N variables. Type-Bound Procedures procedure\n                    ,                  public\n                  :: fcn =>\n                    fnh_fcn Function procedure\n                    ,                  public\n                  :: get_variable_count =>\n                    fnh_get_nvar Function procedure\n                    ,                  public\n                  :: gradient =>\n                    fnh_grad_fcn Subroutine procedure\n                    ,                  public\n                  :: is_fcn_defined =>\n                    fnh_is_fcn_defined Function procedure\n                    ,                  public\n                  :: is_gradient_defined =>\n                    fnh_is_grad_defined Function procedure\n                    ,                  public\n                  :: set_fcn =>\n                    fnh_set_fcn Subroutine procedure\n                    ,                  public\n                  :: set_gradient_fcn =>\n                    fnh_set_grad Subroutine","tags":"","loc":"module\\nonlin_multi_var.html"},{"title":"nonlin_optimize – NONLIN","text":"Uses nonlin_types linalg_errors linalg ferror nonlin_error_handling iso_fortran_env nonlin_linesearch nonlin_multi_var Contents Derived Types bfgs line_search_optimizer nelder_mead Derived Types type, public, extends( line_search_optimizer ) :: bfgs Defines a Broyden–Fletcher–Goldfarb–Shanno (BFGS) solver for\nminimization of functions of multiple variables. Read more… Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_line_search =>\n                    lso_get_line_search Subroutine procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    oe_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    oe_get_print_status Function procedure\n                    ,                  public\n                  :: get_tolerance =>\n                    oe_get_tol Function procedure\n                    ,                  public\n                  :: get_use_line_search =>\n                    lso_get_use_search Function procedure\n                    ,                  public\n                  :: get_var_tolerance =>\n                    lso_get_var_tol Function procedure\n                    ,                  public\n                  :: is_line_search_defined =>\n                    lso_is_line_search_defined Function procedure\n                    ,                  public\n                  :: set_default_line_search =>\n                    lso_set_default Subroutine procedure\n                    ,                  public\n                  :: set_line_search =>\n                    lso_set_line_search Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    oe_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    oe_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_tolerance =>\n                    oe_set_tol Subroutine procedure\n                    ,                  public\n                  :: set_use_line_search =>\n                    lso_set_use_search Subroutine procedure\n                    ,                  public\n                  :: set_var_tolerance =>\n                    lso_set_var_tol Subroutine procedure\n                    ,                  public\n                  :: solve =>\n                    bfgs_solve Subroutine type, public, extends( equation_optimizer ) :: line_search_optimizer A class describing equation optimizers that use a line search\nalgorithm to improve convergence behavior. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_line_search =>\n                    lso_get_line_search Subroutine procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    oe_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    oe_get_print_status Function procedure\n                    ,                  public\n                  :: get_tolerance =>\n                    oe_get_tol Function procedure\n                    ,                  public\n                  :: get_use_line_search =>\n                    lso_get_use_search Function procedure\n                    ,                  public\n                  :: get_var_tolerance =>\n                    lso_get_var_tol Function procedure\n                    ,                  public\n                  :: is_line_search_defined =>\n                    lso_is_line_search_defined Function procedure\n                    ,                  public\n                  :: set_default_line_search =>\n                    lso_set_default Subroutine procedure\n                    ,                  public\n                  :: set_line_search =>\n                    lso_set_line_search Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    oe_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    oe_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_tolerance =>\n                    oe_set_tol Subroutine procedure\n                    ,                  public\n                  :: set_use_line_search =>\n                    lso_set_use_search Subroutine procedure\n                    ,                  public\n                  :: set_var_tolerance =>\n                    lso_set_var_tol Subroutine procedure\n(nonlin_optimize_fcn)                    ,                  public\n, pass                  :: solve type, public, extends( equation_optimizer ) :: nelder_mead Defines a solver based upon Nelder and Mead's simplex algorithm\nfor minimization of functions of multiple variables. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_initial_size =>\n                    nm_get_size Function procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    oe_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    oe_get_print_status Function procedure\n                    ,                  public\n                  :: get_simplex =>\n                    nm_get_simplex Function procedure\n                    ,                  public\n                  :: get_tolerance =>\n                    oe_get_tol Function procedure\n                    ,                  public\n                  :: set_initial_size =>\n                    nm_set_size Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    oe_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    oe_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_simplex =>\n                    nm_set_simplex Subroutine procedure\n                    ,                  public\n                  :: set_tolerance =>\n                    oe_set_tol Subroutine procedure\n                    ,                  public\n                  :: solve =>\n                    nm_solve Subroutine","tags":"","loc":"module\\nonlin_optimize.html"},{"title":"nonlin_polynomials – NONLIN","text":"Uses nonlin_error_handling linalg iso_fortran_env ferror Contents Interfaces assignment(=) operator(*) operator(+) operator(-) Derived Types polynomial Interfaces public        interface assignment(=) Defines polynomial assignment. private  subroutine poly_equals(x, y) Assigns the contents of one polynomial to another. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: x The assignee. class( polynomial ), intent(in) :: y The item to copy. private  subroutine poly_dbl_equals(x, y) Assigns a number to each coefficient of the polynomial. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: x The assignee. real(kind=real64), intent(in) :: y The value to assign. private  subroutine poly_equals_array(x, y) Assigns the contents of an array as polynomial coefficients. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(inout) :: x The assignee. real(kind=real64), intent(in), dimension(:) :: y The coefficient array. public        interface operator(*) Defines polynomial multiplication private  function poly_poly_mult(x, y) result(z) Multiplies two polynomials. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: x The left-hand-side argument. class( polynomial ), intent(in) :: y The right-hand-side argument. Return Value type( polynomial ) The resulting polynomial. private  function poly_dbl_mult(x, y) result(z) Multiplies a polynomial by a scalar value. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: x The left-hand-side argument. real(kind=real64), intent(in) :: y The right-hand-side argument. Return Value type( polynomial ) The resulting polynomial. private  function dbl_poly_mult(x, y) result(z) Multiplies a polynomial by a scalar value. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The left-hand-side argument. class( polynomial ), intent(in) :: y The right-hand-side argument. Return Value type( polynomial ) The resulting polynomial. public        interface operator(+) Defines polynomial addition. private  function poly_poly_add(x, y) result(z) Adds two polynomials. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: x The left-hand-side argument. class( polynomial ), intent(in) :: y The right-hand-side argument. Return Value type( polynomial ) The resulting polynomial. public        interface operator(-) Defines polynomial subtraction. private  function poly_poly_subtract(x, y) result(z) Subtracts two polynomials. Arguments Type Intent Optional Attributes Name class( polynomial ), intent(in) :: x The left-hand-side argument. class( polynomial ), intent(in) :: y The right-hand-side argument. Return Value type( polynomial ) The resulting polynomial. Derived Types type, public :: polynomial Defines a polynomial, and associated routines for performing\npolynomial operations. Type-Bound Procedures procedure\n                    ,                  public\n                  :: companion_mtx =>\n                    poly_companion_mtx Function generic,\n                  public\n                  :: evaluate =>\n                    evaluate_real, evaluate_complex procedure\n                    ,                  public\n                  :: fit =>\n                    poly_fit Subroutine procedure\n                    ,                  public\n                  :: fit_thru_zero =>\n                    poly_fit_thru_zero Subroutine procedure\n                    ,                  public\n                  :: get =>\n                    get_poly_coefficient Function procedure\n                    ,                  public\n                  :: get_all =>\n                    get_poly_coefficients Function generic,\n                  public\n                  :: initialize =>\n                    init_poly, init_poly_coeffs procedure\n                    ,                  public\n                  :: order =>\n                    get_poly_order Function procedure\n                    ,                  public\n                  :: roots =>\n                    poly_roots Function procedure\n                    ,                  public\n                  :: set =>\n                    set_poly_coefficient Subroutine","tags":"","loc":"module\\nonlin_polynomials.html"},{"title":"nonlin_single_var – NONLIN","text":"Uses ferror iso_fortran_env nonlin_types Contents Interfaces fcn1var nonlin_solver_1var Derived Types equation_solver_1var fcn1var_helper Interfaces interface public  function fcn1var(x) result(f) Describes a function of one variable. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The independent variable. Return Value real(kind=real64) The value of the function at x. interface public  subroutine nonlin_solver_1var(this, fcn, x, lim, f, ib, err) Describes the interface of a solver for an equation of one\nvariable. Arguments Type Intent Optional Attributes Name class( equation_solver_1var ), intent(inout) :: this The equation_solver_1var object. class( fcn1var_helper ), intent(in) :: fcn The fcn1var_helper object containing the equation to solve. real(kind=real64), intent(inout) :: x On input the initial guess at the solution.  On output the \nsolution. type( value_pair ), intent(in) :: lim A value_pair object defining the search limits. real(kind=real64), intent(out), optional :: f An optional parameter used to return the function residual \nas computed at x. type( iteration_behavior ), optional :: ib An optional output, that if provided, allows the\ncaller to obtain iteration performance information. class(errors), intent(inout), optional, target :: err An error handling object. Derived Types type, public :: equation_solver_1var A base class for various solvers of equations of one variable. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_diff_tolerance =>\n                    es1_get_diff_tol Function procedure\n                    ,                  public\n                  :: get_fcn_tolerance =>\n                    es1_get_fcn_tol Function procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    es1_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    es1_get_print_status Function procedure\n                    ,                  public\n                  :: get_var_tolerance =>\n                    es1_get_var_tol Function procedure\n                    ,                  public\n                  :: set_diff_tolerance =>\n                    es1_set_diff_tol Subroutine procedure\n                    ,                  public\n                  :: set_fcn_tolerance =>\n                    es1_set_fcn_tol Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    es1_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    es1_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_var_tolerance =>\n                    es1_set_var_tol Subroutine procedure\n(nonlin_solver_1var)                    ,                  public\n, pass                  :: solve type, public :: fcn1var_helper Defines a type capable of encapsulating an equation of one\nvariable of the form: f(x) = 0. Type-Bound Procedures procedure\n                    ,                  public\n                  :: diff =>\n                    f1h_diff_fcn Function procedure\n                    ,                  public\n                  :: fcn =>\n                    f1h_fcn Function procedure\n                    ,                  public\n                  :: is_derivative_defined =>\n                    f1h_is_diff_defined Function procedure\n                    ,                  public\n                  :: is_fcn_defined =>\n                    f1h_is_fcn_defined Function procedure\n                    ,                  public\n                  :: set_diff =>\n                    f1h_set_diff Subroutine procedure\n                    ,                  public\n                  :: set_fcn =>\n                    f1h_set_fcn Subroutine","tags":"","loc":"module\\nonlin_single_var.html"},{"title":"nonlin_solve – NONLIN","text":"Uses nonlin_single_var nonlin_types linalg nonlin_multi_eqn_mult_var ferror nonlin_error_handling iso_fortran_env nonlin_linesearch nonlin_helper Contents Derived Types brent_solver line_search_solver newton_1var_solver newton_solver quasi_newton_solver Derived Types type, public, extends( equation_solver_1var ) :: brent_solver Defines a solver based upon Brent's method for solving an equation\nof one variable without using derivatives. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_diff_tolerance =>\n                    es1_get_diff_tol Function procedure\n                    ,                  public\n                  :: get_fcn_tolerance =>\n                    es1_get_fcn_tol Function procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    es1_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    es1_get_print_status Function procedure\n                    ,                  public\n                  :: get_var_tolerance =>\n                    es1_get_var_tol Function procedure\n                    ,                  public\n                  :: set_diff_tolerance =>\n                    es1_set_diff_tol Subroutine procedure\n                    ,                  public\n                  :: set_fcn_tolerance =>\n                    es1_set_fcn_tol Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    es1_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    es1_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_var_tolerance =>\n                    es1_set_var_tol Subroutine procedure\n                    ,                  public\n                  :: solve =>\n                    brent_solve Subroutine type, public, extends( equation_solver ) :: line_search_solver A class describing nonlinear solvers that use a line search\nalgorithm to improve convergence behavior. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_fcn_tolerance =>\n                    es_get_fcn_tol Function procedure\n                    ,                  public\n                  :: get_gradient_tolerance =>\n                    es_get_grad_tol Function procedure\n                    ,                  public\n                  :: get_line_search =>\n                    lss_get_line_search Subroutine procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    es_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    es_get_print_status Function procedure\n                    ,                  public\n                  :: get_use_line_search =>\n                    lss_get_use_search Function procedure\n                    ,                  public\n                  :: get_var_tolerance =>\n                    es_get_var_tol Function procedure\n                    ,                  public\n                  :: is_line_search_defined =>\n                    lss_is_line_search_defined Function procedure\n                    ,                  public\n                  :: set_default_line_search =>\n                    lss_set_default Subroutine procedure\n                    ,                  public\n                  :: set_fcn_tolerance =>\n                    es_set_fcn_tol Subroutine procedure\n                    ,                  public\n                  :: set_gradient_tolerance =>\n                    es_set_grad_tol Subroutine procedure\n                    ,                  public\n                  :: set_line_search =>\n                    lss_set_line_search Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    es_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    es_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_use_line_search =>\n                    lss_set_use_search Subroutine procedure\n                    ,                  public\n                  :: set_var_tolerance =>\n                    es_set_var_tol Subroutine procedure\n(nonlin_solver)                    ,                  public\n, pass                  :: solve type, public, extends( equation_solver_1var ) :: newton_1var_solver Defines a solver based upon Newtons's method for solving an\nequation of one variable.  The algorithm uses a bisection method in\nconjunction with Newton's method in order to keep bounds upon the\nNewton iterations. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_diff_tolerance =>\n                    es1_get_diff_tol Function procedure\n                    ,                  public\n                  :: get_fcn_tolerance =>\n                    es1_get_fcn_tol Function procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    es1_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    es1_get_print_status Function procedure\n                    ,                  public\n                  :: get_var_tolerance =>\n                    es1_get_var_tol Function procedure\n                    ,                  public\n                  :: set_diff_tolerance =>\n                    es1_set_diff_tol Subroutine procedure\n                    ,                  public\n                  :: set_fcn_tolerance =>\n                    es1_set_fcn_tol Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    es1_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    es1_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_var_tolerance =>\n                    es1_set_var_tol Subroutine procedure\n                    ,                  public\n                  :: solve =>\n                    newt1var_solve Subroutine type, public, extends( line_search_solver ) :: newton_solver Defines a Newton solver. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_fcn_tolerance =>\n                    es_get_fcn_tol Function procedure\n                    ,                  public\n                  :: get_gradient_tolerance =>\n                    es_get_grad_tol Function procedure\n                    ,                  public\n                  :: get_line_search =>\n                    lss_get_line_search Subroutine procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    es_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    es_get_print_status Function procedure\n                    ,                  public\n                  :: get_use_line_search =>\n                    lss_get_use_search Function procedure\n                    ,                  public\n                  :: get_var_tolerance =>\n                    es_get_var_tol Function procedure\n                    ,                  public\n                  :: is_line_search_defined =>\n                    lss_is_line_search_defined Function procedure\n                    ,                  public\n                  :: set_default_line_search =>\n                    lss_set_default Subroutine procedure\n                    ,                  public\n                  :: set_fcn_tolerance =>\n                    es_set_fcn_tol Subroutine procedure\n                    ,                  public\n                  :: set_gradient_tolerance =>\n                    es_set_grad_tol Subroutine procedure\n                    ,                  public\n                  :: set_line_search =>\n                    lss_set_line_search Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    es_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    es_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_use_line_search =>\n                    lss_set_use_search Subroutine procedure\n                    ,                  public\n                  :: set_var_tolerance =>\n                    es_set_var_tol Subroutine procedure\n                    ,                  public\n                  :: solve =>\n                    ns_solve Subroutine type, public, extends( line_search_solver ) :: quasi_newton_solver Defines a quasi-Newton type solver based upon Broyden's method. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_fcn_tolerance =>\n                    es_get_fcn_tol Function procedure\n                    ,                  public\n                  :: get_gradient_tolerance =>\n                    es_get_grad_tol Function procedure\n                    ,                  public\n                  :: get_jacobian_interval =>\n                    qns_get_jac_interval Function procedure\n                    ,                  public\n                  :: get_line_search =>\n                    lss_get_line_search Subroutine procedure\n                    ,                  public\n                  :: get_max_fcn_evals =>\n                    es_get_max_eval Function procedure\n                    ,                  public\n                  :: get_print_status =>\n                    es_get_print_status Function procedure\n                    ,                  public\n                  :: get_use_line_search =>\n                    lss_get_use_search Function procedure\n                    ,                  public\n                  :: get_var_tolerance =>\n                    es_get_var_tol Function procedure\n                    ,                  public\n                  :: is_line_search_defined =>\n                    lss_is_line_search_defined Function procedure\n                    ,                  public\n                  :: set_default_line_search =>\n                    lss_set_default Subroutine procedure\n                    ,                  public\n                  :: set_fcn_tolerance =>\n                    es_set_fcn_tol Subroutine procedure\n                    ,                  public\n                  :: set_gradient_tolerance =>\n                    es_set_grad_tol Subroutine procedure\n                    ,                  public\n                  :: set_jacobian_interval =>\n                    qns_set_jac_interval Subroutine procedure\n                    ,                  public\n                  :: set_line_search =>\n                    lss_set_line_search Subroutine procedure\n                    ,                  public\n                  :: set_max_fcn_evals =>\n                    es_set_max_eval Subroutine procedure\n                    ,                  public\n                  :: set_print_status =>\n                    es_set_print_status Subroutine procedure\n                    ,                  public\n                  :: set_use_line_search =>\n                    lss_set_use_search Subroutine procedure\n                    ,                  public\n                  :: set_var_tolerance =>\n                    es_set_var_tol Subroutine procedure\n                    ,                  public\n                  :: solve =>\n                    qns_solve Subroutine","tags":"","loc":"module\\nonlin_solve.html"},{"title":"nonlin_types – NONLIN","text":"Uses iso_fortran_env Contents Derived Types iteration_behavior value_pair Derived Types type, public :: iteration_behavior Defines a set of parameters that describe the behavior of the\niteration process. Components Type Visibility Attributes Name Initial logical, public :: converge_on_chng True if the solution converged as a result of no appreciable\nchange in solution points between iterations; else, false. logical, public :: converge_on_fcn True if the solution converged as a result of a zero-valued\nfunction; else, false. logical, public :: converge_on_zero_diff True if the solution appears to have settled on a stationary\npoint such that the gradient of the function is zero-valued; \nelse, false. integer(kind=int32), public :: fcn_count Specifies the number of function evaluations performed. integer(kind=int32), public :: gradient_count Specifies the number of gradient vector evaluations performed. integer(kind=int32), public :: iter_count Specifies the number of iterations performed. integer(kind=int32), public :: jacobian_count Specifies the number of Jacobian evaluations performed. type, public :: value_pair Defines a pair of numeric values. Components Type Visibility Attributes Name Initial real(kind=real64), public :: x1 Value 1. real(kind=real64), public :: x2 Value 2.","tags":"","loc":"module\\nonlin_types.html"},{"title":"nonlin.f90 – NONLIN","text":"Contents Modules nonlin Source Code nonlin.f90 Source Code module nonlin use nonlin_multi_eqn_mult_var use nonlin_single_var use nonlin_multi_var use nonlin_types use nonlin_least_squares use nonlin_linesearch use nonlin_optimize use nonlin_solve use nonlin_polynomials implicit none ! NONLIN_MULTI_EQN_MULTI_VAR public :: vecfcn public :: jacobianfcn public :: vecfcn_helper public :: equation_solver public :: nonlin_solver ! NONLIN_SINGLE_VAR public :: fcn1var public :: fcn1var_helper public :: equation_solver_1var public :: nonlin_solver_1var ! NONLIN_MULTI_VAR public :: fcnnvar public :: gradientfcn public :: fcnnvar_helper public :: equation_optimizer public :: nonlin_optimize_fcn ! NONLIN_TYPES public :: iteration_behavior public :: value_pair ! NONLIN_LEAST_SQUARES public :: least_squares_solver ! NONLIN_LINESEARCH public :: line_search public :: limit_search_vector ! NONLIN_OPTIMIZE public :: nelder_mead public :: line_search_optimizer public :: bfgs ! NONLIN_SOLVE public :: line_search_solver public :: quasi_newton_solver public :: newton_solver public :: brent_solver public :: newton_1var_solver ! NONLIN_POLYNOMIALS public :: polynomial public :: assignment ( = ) public :: operator ( + ) public :: operator ( - ) public :: operator ( * ) end module","tags":"","loc":"sourcefile\\nonlin.f90.html"},{"title":"nonlin_error_handling.f90 – NONLIN","text":"Contents Modules nonlin_error_handling Source Code nonlin_error_handling.f90 Source Code module nonlin_error_handling use iso_fortran_env use linalg_errors , only : LA_OUT_OF_MEMORY_ERROR , LA_CONVERGENCE_ERROR , & LA_INVALID_OPERATION_ERROR implicit none ! ****************************************************************************** ! ERROR FLAGS ! ------------------------------------------------------------------------------ !> A flag denoting no error. integer ( int32 ), parameter :: NL_NO_ERROR = 0 !> An error flag denoting an invalid input. integer ( int32 ), parameter :: NL_INVALID_INPUT_ERROR = 201 !> An error flag denoting an improperly sized array. integer ( int32 ), parameter :: NL_ARRAY_SIZE_ERROR = 202 !> An error denoting that there is insufficient memory available. integer ( int32 ), parameter :: NL_OUT_OF_MEMORY_ERROR = LA_OUT_OF_MEMORY_ERROR !> An error resulting from an invalid operation. integer ( int32 ), parameter :: NL_INVALID_OPERATION_ERROR = & LA_INVALID_OPERATION_ERROR !> An error resulting from a lack of convergence. integer ( int32 ), parameter :: NL_CONVERGENCE_ERROR = LA_CONVERGENCE_ERROR !> An error resulting from a divergent condition. integer ( int32 ), parameter :: NL_DIVERGENT_BEHAVIOR_ERROR = 206 !> An error indicating a possible spurious convergence condition. integer ( int32 ), parameter :: NL_SPURIOUS_CONVERGENCE_ERROR = 207 !> An error indicating the user-requested tolerance is too small to be !! practical for the problem at hand. integer ( int32 ), parameter :: NL_TOLERANCE_TOO_SMALL_ERROR = 208 end module","tags":"","loc":"sourcefile\\nonlin_error_handling.f90.html"},{"title":"nonlin_helper.f90 – NONLIN","text":"Contents Modules nonlin_helper Source Code nonlin_helper.f90 Source Code module nonlin_helper use iso_fortran_env implicit none private public :: print_status public :: test_convergence contains ! ------------------------------------------------------------------------------ !> @brief Prints the iteration status. !! !! @param[in] iter The iteration number. !! @param[in] nfeval The number of function evaluations. !! @param[in] njaceval The number of Jacobian evaluations. !! @param[in] xnorm The change in variable value. !! @param[in] fnorm The residual. subroutine print_status ( iter , nfeval , njaceval , xnorm , fnorm ) ! Arguments integer ( int32 ), intent ( in ) :: iter , nfeval , njaceval real ( real64 ), intent ( in ) :: xnorm , fnorm ! Process print * , \"\" print 100 , \"Iteration: \" , iter print 100 , \"Function Evaluations: \" , nfeval if ( njaceval > 0 ) print 100 , \"Jacobian Evaluations: \" , njaceval print 101 , \"Change in Variable: \" , xnorm print 101 , \"Residual: \" , fnorm ! Formatting 100 format ( A , I0 ) 101 format ( A , E10 . 3 ) end subroutine ! ------------------------------------------------------------------------------ subroutine test_convergence ( x , xo , f , g , lg , xtol , ftol , gtol , c , cx , cf , & cg , xnorm , fnorm ) !! Tests for convergence. real ( real64 ), intent ( in ), dimension (:) :: x !! The current solution estimate. real ( real64 ), intent ( in ), dimension (:) :: xo !! The previous solution estimate. real ( real64 ), intent ( in ), dimension (:) :: f !! The current residual based upon x. real ( real64 ), intent ( in ), dimension (:) :: g !! The current estimate of the gradient vector at x. logical , intent ( in ) :: lg !! Set to true if the gradient slope check should be performed; !! else, false. real ( real64 ), intent ( in ) :: xtol !! The tolerance on the change in variable. real ( real64 ), intent ( in ) :: ftol !! The tolerance on the residual. real ( real64 ), intent ( in ) :: gtol !! The tolerance on the slope of the gradient. logical , intent ( out ) :: c !! True if the solution converged on either the residual or !! change in variable. logical , intent ( out ) :: cx !! True if convergence occurred due to change in variable. logical , intent ( out ) :: cf !! True if convergence occurred due to residual. logical , intent ( out ) :: cg !! True if convergence occured due to slope of the gradient. real ( real64 ), intent ( out ) :: xnorm !! The largest magnitude component of the scaled change in variable !! vector. real ( real64 ), intent ( out ) :: fnorm !! The largest magnitude residual component. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: half = 0.5d0 ! Local Variables integer ( int32 ) :: i , nvar , neqn real ( real64 ) :: test , dxmax , fc , den ! Initialization nvar = size ( x ) neqn = size ( f ) cx = . false . cf = . false . cg = . false . c = . false . fc = half * dot_product ( f , f ) fnorm = zero xnorm = zero ! Test for convergence on residual do i = 1 , neqn fnorm = max ( abs ( f ( i )), fnorm ) end do if ( fnorm < ftol ) then cf = . true . c = . true . return end if ! Test the change in solution do i = 1 , nvar test = abs ( x ( i ) - xo ( i )) / max ( abs ( x ( i )), one ) xnorm = max ( test , xnorm ) end do if ( xnorm < xtol ) then cx = . true . c = . true . return end if ! Test for zero gradient slope - do not set convergence flag if ( lg ) then test = zero den = max ( fc , half * nvar ) do i = 1 , nvar dxmax = abs ( g ( i )) * max ( abs ( x ( i )), one ) / den test = max ( test , dxmax ) end do if ( test < gtol ) then cg = . true . end if end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\nonlin_helper.f90.html"},{"title":"nonlin_least_squares.f90 – NONLIN","text":"Contents Modules nonlin_least_squares Source Code nonlin_least_squares.f90 Source Code module nonlin_least_squares use iso_fortran_env use nonlin_multi_eqn_mult_var use nonlin_error_handling use nonlin_types use nonlin_helper use ferror , only : errors implicit none private public :: least_squares_solver ! ****************************************************************************** ! TYPES ! ------------------------------------------------------------------------------ !> @brief Defines a Levenberg-Marquardt based solver for unconstrained !! least-squares problems. type , extends ( equation_solver ) :: least_squares_solver !! Defines a Levenberg-Marquardt based solver for unconstrained !! least-squares problems. real ( real64 ), private :: m_factor = 10 0.0d0 !! Initial step bounding factor contains procedure , public :: get_step_scaling_factor => lss_get_factor procedure , public :: set_step_scaling_factor => lss_set_factor procedure , public :: solve => lss_solve end type contains ! ****************************************************************************** ! LEAST_SQUARES_SOLVER MEMBERS ! ------------------------------------------------------------------------------ pure function lss_get_factor ( this ) result ( x ) !! Gets a factor used to scale the bounds on the initial step. !! !! This factor is used to set the bounds on the initial step such that !! the initial step is bounded as the product of the factor with the !! Euclidean norm of the vector resulting from multiplication of the !! diagonal scaling matrix and the solution estimate.  If zero, the !! factor itself is used. class ( least_squares_solver ), intent ( in ) :: this !! The [[least_squares_solver]] object. real ( real64 ) :: x !! The factor. x = this % m_factor end function ! -------------------- subroutine lss_set_factor ( this , x ) !! Sets a factor used to scale the bounds on the initial step. !! !! This factor is used to set the bounds on the initial step such that !! the initial step is bounded as the product of the factor with the !! Euclidean norm of the vector resulting from multiplication of the !! diagonal scaling matrix and the solution estimate.  If zero, the !! factor itself is used. class ( least_squares_solver ), intent ( inout ) :: this !! The [[least_squares_solver]] object. real ( real64 ), intent ( in ) :: x !! The factor. if ( x < 0.1d0 ) then this % m_factor = 0.1d0 else if ( x > 1.0d2 ) then this % m_factor = 1.0d2 else this % m_factor = x end if end subroutine ! ------------------------------------------------------------------------------ subroutine lss_solve ( this , fcn , x , fvec , ib , err ) !! Applies the Levenberg-Marquardt method to solve the nonlinear !! least-squares problem.  This routines is based upon the MINPACK !! routine LMDIF. class ( least_squares_solver ), intent ( inout ) :: this !! The [[least_squares_solver]] object. class ( vecfcn_helper ), intent ( in ) :: fcn !! The [[vecfcn_helper]] object containing the equations to solve. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, an N-element array containing an initial estimate !! to the solution.  On output, the updated solution estimate. !! N is the number of variables. real ( real64 ), intent ( out ), dimension (:) :: fvec !! An M-element array that, on output, will contain the values !! of each equation as evaluated at the variable values given !! in x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: p0001 = 1.0d-4 real ( real64 ), parameter :: p1 = 0.1d0 real ( real64 ), parameter :: qtr = 0.25d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: p75 = 0.75d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: hndrd = 1.0d2 ! Local Variables logical :: xcnvrg , fcnvrg , gcnvrg integer ( int32 ) :: i , neqn , nvar , flag , neval , iter , j , l , maxeval , & njac , lwork integer ( int32 ), allocatable , dimension (:) :: jpvt real ( real64 ) :: ftol , xtol , gtol , fac , eps , fnorm , par , xnorm , delta , & sm , temp , gnorm , pnorm , fnorm1 , actred , temp1 , temp2 , prered , & dirder , ratio real ( real64 ), allocatable , dimension (:,:) :: jac real ( real64 ), allocatable , dimension (:) :: diag , qtf , wa1 , wa2 , wa3 , wa4 , w class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 256 ) :: errmsg ! Initialization xcnvrg = . false . fcnvrg = . false . gcnvrg = . false . neqn = fcn % get_equation_count () nvar = fcn % get_variable_count () neval = 0 iter = 0 njac = 0 fac = this % m_factor ftol = this % get_fcn_tolerance () xtol = this % get_var_tolerance () gtol = this % get_gradient_tolerance () maxeval = this % get_max_fcn_evals () eps = epsilon ( eps ) if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = njac ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = gcnvrg end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if (. not . fcn % is_fcn_defined ()) then ! ERROR: No function is defined call errmgr % report_error ( \"lss_solve\" , & \"No function has been defined.\" , & NL_INVALID_OPERATION_ERROR ) return end if if ( nvar > neqn ) then ! ERROR: System is underdetermined call errmgr % report_error ( \"lss_solve\" , \"The solver cannot \" // & \"solve the underdetermined problem.  The number of \" // & \"unknowns must not exceed the number of equations.\" , & NL_INVALID_INPUT_ERROR ) return end if flag = 0 if ( size ( x ) /= nvar ) then flag = 3 else if ( size ( fvec ) /= neqn ) then flag = 4 end if if ( flag /= 0 ) then ! One of the input arrays is not sized correctly write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"lss_solve\" , trim ( errmsg ), & NL_ARRAY_SIZE_ERROR ) return end if ! Local Memory Allocation allocate ( jpvt ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( jac ( neqn , nvar ), stat = flag ) if ( flag == 0 ) allocate ( diag ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( qtf ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( wa1 ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( wa2 ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( wa3 ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( wa4 ( neqn ), stat = flag ) if ( flag == 0 ) then call fcn % jacobian ( x , jac , fv = fvec , olwork = lwork ) allocate ( w ( lwork ), stat = flag ) end if if ( flag /= 0 ) then ! ERROR: Out of memory call errmgr % report_error ( \"qns_solve\" , & \"Insufficient memory available.\" , NL_OUT_OF_MEMORY_ERROR ) return end if ! Evaluate the function at the starting point, and calculate its norm call fcn % fcn ( x , fvec ) neval = 1 fnorm = norm2 ( fvec ) ! Process par = zero iter = 1 flag = 0 do ! Evaluate the Jacobian call fcn % jacobian ( x , jac , fvec , w ) njac = njac + 1 ! Compute the QR factorization of the Jacobian call lmfactor ( jac , . true ., jpvt , wa1 , wa2 , wa3 ) ! On the first iteration, scale the problem according to the norms ! of each of the columns of the initial Jacobian if ( iter == 1 ) then do j = 1 , nvar diag ( j ) = wa2 ( j ) if ( wa2 ( j ) == zero ) diag ( j ) = one end do wa3 = diag * x xnorm = norm2 ( wa3 ) delta = fac * xnorm if ( delta == zero ) delta = fac end if ! Form Q**T * FVEC, and store the first N components in QTF wa4 = fvec do j = 1 , nvar if ( jac ( j , j ) /= zero ) then sm = zero do i = j , neqn sm = sm + jac ( i , j ) * wa4 ( i ) end do temp = - sm / jac ( j , j ) wa4 ( j : neqn ) = wa4 ( j : neqn ) + jac ( j : neqn , j ) * temp end if ! LINE 120 jac ( j , j ) = wa1 ( j ) qtf ( j ) = wa4 ( j ) end do ! Compute the norm of the scaled gradient gnorm = zero if ( fnorm /= zero ) then do j = 1 , nvar l = jpvt ( j ) if ( wa2 ( l ) == zero ) cycle sm = zero do i = 1 , j sm = sm + jac ( i , j ) * ( qtf ( i ) / fnorm ) end do gnorm = max ( gnorm , abs ( sm / wa2 ( l ))) end do end if ! LINE 170 ! Test for convergence of the gradient norm if ( gnorm <= gtol ) then gcnvrg = . true . exit end if ! Rescale if necessary do j = 1 , nvar diag ( j ) = max ( diag ( j ), wa2 ( j )) end do ! Inner Loop do ! Determine the Levenberg-Marquardt parameter call lmpar ( jac , jpvt , diag , qtf , delta , par , wa1 , wa2 , wa3 , wa4 ) ! Store the direction P, and X + P.  Calculate the norm of P do j = 1 , nvar wa1 ( j ) = - wa1 ( j ) wa2 ( j ) = x ( j ) + wa1 ( j ) wa3 ( j ) = diag ( j ) * wa1 ( j ) end do pnorm = norm2 ( wa3 ) ! On the first iteration, adjust the initial step bounds if ( iter == 1 ) delta = min ( delta , pnorm ) ! Evaluate the function at X + P, and calculate its norm call fcn % fcn ( wa2 , wa4 ) neval = neval + 1 fnorm1 = norm2 ( wa4 ) ! Compute the scaled actual reduction actred = - one if ( p1 * fnorm1 < fnorm ) actred = one - ( fnorm1 / fnorm ) ** 2 ! Compute the scaled predicted reduction and the scaled ! directional derivative do j = 1 , nvar wa3 ( j ) = zero l = jpvt ( j ) temp = wa1 ( l ) wa3 ( 1 : j ) = wa3 ( 1 : j ) + jac ( 1 : j , j ) * temp end do temp1 = norm2 ( wa3 ) / fnorm temp2 = ( sqrt ( par ) * pnorm ) / fnorm prered = temp1 ** 2 + temp2 ** 2 / half dirder = - ( temp1 ** 2 + temp2 ** 2 ) ! Compute the ratio of the actual to the predicted reduction ratio = zero if ( prered /= zero ) ratio = actred / prered ! Update the step bounds if ( ratio <= qtr ) then if ( actred >= zero ) temp = half if ( actred < zero ) temp = half * dirder / & ( dirder + half * actred ) if ( p1 * fnorm1 >= fnorm . or . temp < p1 ) temp = p1 delta = temp * min ( delta , pnorm / p1 ) par = par / temp else if ( par /= zero . and . ratio < p75 ) then ! NO ACTION REQUIRED else delta = pnorm / half par = half * par end if end if ! LINE 240 ! Test for successful iteration if ( ratio >= p0001 ) then do j = 1 , nvar x ( j ) = wa2 ( j ) wa2 ( j ) = diag ( j ) * x ( j ) end do fvec = wa4 xnorm = norm2 ( wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! LINE 290 ! Tests for convergence if ( abs ( actred ) <= ftol . and . prered <= ftol . and . & half * ratio <= one ) fcnvrg = . true . if ( delta <= xtol * xnorm ) xcnvrg = . true . if ( fcnvrg . or . xcnvrg ) exit ! Tests for termination and stringent tolerances if ( neval >= maxeval ) flag = NL_CONVERGENCE_ERROR if ( abs ( actred ) <= eps . and . prered <= eps . and . & half * ratio <= one ) flag = NL_TOLERANCE_TOO_SMALL_ERROR if ( delta <= eps * xnorm ) flag = NL_TOLERANCE_TOO_SMALL_ERROR if ( gnorm <= eps ) flag = NL_TOLERANCE_TOO_SMALL_ERROR if ( flag /= 0 ) exit if ( ratio >= p0001 ) exit end do ! End of the inner loop ! Check for termination criteria if ( fcnvrg . or . xcnvrg . or . gcnvrg . or . flag /= 0 ) exit ! Print the iteration status if ( this % get_print_status ()) then call print_status ( iter , neval , njac , xnorm , fnorm ) end if end do ! Report out iteration statistics if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = njac ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = gcnvrg end if ! Check for convergence issues if ( flag /= 0 ) then write ( errmsg , 101 ) \"The algorithm failed to \" // & \"converge.  Function evaluations performed: \" , neval , & \".\" // new_line ( 'c' ) // \"Change in Variable: \" , xnorm , & new_line ( 'c' ) // \"Residual: \" , fnorm call errmgr % report_error ( \"lss_solve\" , trim ( errmsg ), & flag ) end if ! Formatting 100 format ( A , I0 , A ) 101 format ( A , I0 , A , E10 . 3 , A , E10 . 3 ) end subroutine ! ------------------------------------------------------------------------------ subroutine lmpar ( r , ipvt , diag , qtb , delta , par , x , sdiag , wa1 , wa2 ) !! Completes the solution of the Levenberg-Marquardt problem when !! provided with a QR factored form of the system Jacobian matrix.  The !! form of the problem at this stage is J*X = B (J = Jacobian), and !! D*X = 0, where D is a diagonal matrix. !! !! This routines is based upon the MINPACK routine LMPAR. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the N-by-N upper triangular matrix R1 of the !! QR factorization.  On output, the upper triangular portion is !! unaltered, but the strict lower triangle contains the strict !! upper triangle (transposed) of the matrix S. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! An N-element array tracking the pivoting operations from the !! original QR factorization. real ( real64 ), intent ( in ), dimension (:) :: diag !! An N-element array containing the diagonal components of the !! matrix D. real ( real64 ), intent ( in ), dimension (:) :: qtb !! An N-element array containing the first N elements of Q1**T * B. real ( real64 ), intent ( in ) :: delta !! A positive input variable that specifies an upper bounds on the !! Euclidean norm of D*X. real ( real64 ), intent ( inout ) :: par !! On input, the initial estimate of the Levenberg-Marquardt !! parameter.  On output, the final estimate. real ( real64 ), intent ( out ), dimension (:) :: x !! The N-element array that is the solution of A*X = B, and of !! D*X = 0. real ( real64 ), intent ( out ), dimension (:) :: sdiag !! An N-element array containing the diagonal elements of the !! matrix S. real ( real64 ), intent ( out ), dimension (:) :: wa1 !! An N-element workspace array. real ( real64 ), intent ( out ), dimension (:) :: wa2 !! An N-element workspace array. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: p001 = 1.0d-3 real ( real64 ), parameter :: p1 = 0.1d0 ! Local Variables integer :: iter , j , jm1 , jp1 , k , l , nsing , n real ( real64 ) :: dxnorm , dwarf , fp , gnorm , parc , parl , paru , sm , temp ! Initialization n = size ( r , 2 ) ! NOTE: R is M-by-N dwarf = tiny ( dwarf ) nsing = n ! Compute and store in X, the Gauss-Newton direction.  If the Jacobian ! is rank deficient, obtain a least-squares solution. do j = 1 , n wa1 ( j ) = qtb ( j ) if ( r ( j , j ) == zero . and . nsing == n ) nsing = j - 1 if ( nsing < n ) wa1 ( j ) = zero end do ! LINE 10 if ( nsing >= 1 ) then do k = 1 , nsing j = nsing - k + 1 wa1 ( j ) = wa1 ( j ) / r ( j , j ) temp = wa1 ( j ) jm1 = j - 1 if ( jm1 >= 1 ) then wa1 ( 1 : jm1 ) = wa1 ( 1 : jm1 ) - r ( 1 : jm1 , j ) * temp end if end do ! LINE 40 end if ! LINE 50 do j = 1 , n l = ipvt ( j ) x ( l ) = wa1 ( j ) end do ! Initialize the iteration counter, evaluate the function at the origin, ! and test for acceptance of the Gauss-Newton direction. iter = 0 wa2 ( 1 : n ) = diag * x dxnorm = norm2 ( wa2 ( 1 : n )) fp = dxnorm - delta if ( fp <= p1 * delta ) then ! LINE 220 if ( iter == 0 ) par = zero return end if ! If the Jacobian is not rank deficient, the Newton step provides a ! lower bound, PARL, for the zero of the function; else, set this bound ! to zero parl = zero if ( nsing == n ) then do j = 1 , n l = ipvt ( j ) wa1 ( j ) = diag ( l ) * ( wa2 ( l ) / dxnorm ) end do ! LINE 80 do j = 1 , n sm = zero jm1 = j - 1 if ( jm1 >= 1 ) then sm = dot_product ( r ( 1 : jm1 , j ), wa1 ( 1 : jm1 )) end if wa1 ( j ) = ( wa1 ( j ) - sm ) / r ( j , j ) end do ! LINE 110 temp = norm2 ( wa1 ) parl = (( fp / delta ) / temp ) / temp end if ! Calculate an upper bound, PARU, for the zero of the function do j = 1 , n sm = dot_product ( r ( 1 : j , j ), qtb ( 1 : j )) l = ipvt ( j ) wa1 ( j ) = sm / diag ( l ) end do ! LINE 140 gnorm = norm2 ( wa1 ) paru = gnorm / delta if ( paru == zero ) paru = dwarf / min ( delta , p1 ) ! If the input PAR lies outside of the interval (PARL,PARU), set ! PAR to the closer end point. par = max ( par , parl ) par = min ( par , paru ) if ( par == zero ) par = gnorm / dxnorm ! Iteration do iter = iter + 1 ! Evaluate the function at the current value of PAR if ( par == zero ) par = max ( dwarf , p001 * paru ) temp = sqrt ( par ) wa1 = temp * diag call lmsolve ( r ( 1 : n , 1 : n ), ipvt , wa1 , qtb , x , sdiag , wa2 ) wa2 ( 1 : n ) = diag * x dxnorm = norm2 ( wa2 ) temp = fp fp = dxnorm - delta ! If the function is small enough, accept the current value of PAR. ! Also test for the exceptional cases where PARL is zero, or the ! number of iterations has reached 10 if ( abs ( fp ) <= p1 * delta & . or . parl == zero . and . fp <= temp & . and . temp < zero . or . iter == 10 ) exit ! Compute the Newton correction do j = 1 , n l = ipvt ( j ) wa1 ( j ) = diag ( l ) * ( wa2 ( l ) / dxnorm ) end do ! LINE 180 do j = 1 , n wa1 ( j ) = wa1 ( J ) / sdiag ( j ) temp = wa1 ( j ) jp1 = j + 1 if ( n < jp1 ) cycle wa1 = wa1 - r ( 1 : n , j ) * temp end do ! LINE 210 temp = norm2 ( wa1 ) parc = (( fp / delta ) / temp ) / temp ! Depending on the sign of the function update PARL or PARU if ( fp > zero ) parl = max ( parl , par ) if ( fp < zero ) paru = min ( paru , par ) ! Compute an improved estimate for PAR par = max ( parl , par + parc ) end do ! LINE 220 (End of iteration) if ( iter == zero ) par = zero return end subroutine ! ------------------------------------------------------------------------------ subroutine lmfactor ( a , pivot , ipvt , rdiag , acnorm , wa ) !! Computes the QR factorization of an M-by-N matrix. !! !! This routines is based upon the MINPACK routine QRFAC. real ( real64 ), intent ( inout ), dimension (:,:) :: a !! On input, the M-by-N matrix to factor.  On output, the strict !! upper triangular portion contains matrix R1 of the factorization, !! the lower trapezoidal portion contains the factored form of Q1, !! and the diagonal contains the corresponding elementary reflector. logical , intent ( in ) :: pivot !! Set to true to utilize column pivoting; else, set to false for !! no pivoting. integer ( int32 ), intent ( out ), dimension (:) :: ipvt !! An N-element array that is used to contain the pivot indices !! unless pivot is set to false.  In such event, this array is !! unused. real ( real64 ), intent ( out ), dimension (:) :: rdiag !! An N-element array used to store the diagonal elements of the !! R1 matrix. real ( real64 ), intent ( out ), dimension (:) :: acnorm !! An N-element array used to contain the norms of each column in !! the event column pivoting is used.  If pivoting is not used, !! this array is unused. real ( real64 ), intent ( out ), dimension (:) :: wa !! An N-element workspace array. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: p05 = 5.0d-2 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: m , n , i , j , jp1 , k , kmax , minmn real ( real64 ) :: ajnorm , epsmch , sm , temp ! Initialization m = size ( a , 1 ) n = size ( a , 2 ) minmn = min ( m , n ) epsmch = epsilon ( epsmch ) ! Compute the initial column norms, and initialize several arrays do j = 1 , n acnorm ( j ) = norm2 ( a (:, j )) rdiag ( j ) = acnorm ( j ) wa ( j ) = rdiag ( j ) if ( pivot ) ipvt ( j ) = j end do ! LINE 10 ! Reduce A to R with Householder transformations do j = 1 , minmn if ( pivot ) then ! Bring the column of largest norm into the pivot position kmax = j do k = j , n if ( rdiag ( k ) > rdiag ( kmax )) kmax = k end do ! LINE 20 if ( kmax /= j ) then do i = 1 , m temp = a ( i , j ) a ( i , j ) = a ( i , kmax ) a ( i , kmax ) = temp end do ! LINE 30 rdiag ( kmax ) = rdiag ( j ) wa ( kmax ) = wa ( j ) k = ipvt ( j ) ipvt ( j ) = ipvt ( kmax ) ipvt ( kmax ) = k end if end if ! LINE 40 ! Compute the Householder transformation to reduce the J-th column ! of A to a multiple of the J-th unit vector ajnorm = norm2 ( a ( j : m , j )) if ( ajnorm /= zero ) then if ( a ( j , j ) < zero ) ajnorm = - ajnorm a ( j : m , j ) = a ( j : m , j ) / ajnorm a ( j , j ) = a ( j , j ) + one ! Apply the transformation to the remaining columns and update ! the norms jp1 = j + 1 if ( n >= jp1 ) then do k = jp1 , n sm = dot_product ( a ( j : m , j ), a ( j : m , k )) temp = sm / a ( j , j ) a ( j : m , k ) = a ( j : m , k ) - temp * a ( j : m , j ) if (. not . pivot . or . rdiag ( k ) == zero ) cycle temp = a ( j , k ) / rdiag ( k ) rdiag ( k ) = rdiag ( k ) * sqrt ( max ( zero , one - temp ** 2 )) if ( p05 * ( rdiag ( k ) / wa ( k )) ** 2 > epsmch ) cycle rdiag ( k ) = norm2 ( a ( jp1 : m , k )) wa ( k ) = rdiag ( k ) end do ! LINE 90 end if end if ! LINE 100 rdiag ( j ) = - ajnorm end do ! LINE 110 end subroutine ! ------------------------------------------------------------------------------ subroutine lmsolve ( r , ipvt , diag , qtb , x , sdiag , wa ) !! Solves the QR factored system A*X = B, coupled with the diagonal !! system D*X = 0 in the least-squares sense. !! !! This routines is based upon the MINPACK routine QRSOLV. real ( real64 ), intent ( inout ), dimension (:,:) :: r !! On input, the N-by-N upper triangular matrix R1 of the QR !! factorization.  On output, the upper triangular portion is !! unaltered, but the strict lower triangle contains the strict !! upper triangle (transposed) of the matrix S. integer ( int32 ), intent ( in ), dimension (:) :: ipvt !! An N-element array tracking the pivoting operations from the !! original QR factorization. real ( real64 ), intent ( in ), dimension (:) :: diag !! An N-element array containing the diagonal components of the !! matrix D. real ( real64 ), intent ( in ), dimension (:) :: qtb !! An N-element array containing the first N elements of Q1**T * B. real ( real64 ), intent ( out ), dimension (:) :: x !! The N-element array that is the solution of A*X = B, and of !! D*X = 0. real ( real64 ), intent ( out ), dimension (:) :: sdiag !! An N-element array containing the diagonal elements of the !! matrix S. real ( real64 ), intent ( out ), dimension (:) :: wa !! An N-element workspace array. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: qtr = 0.25d0 real ( real64 ), parameter :: half = 0.5d0 ! Local Variables integer ( int32 ) :: n , i , j , jp1 , k , kp1 , l , nsing real ( real64 ) :: cs , ctan , qtbpj , sn , sm , tn , temp ! Initialization n = size ( r , 1 ) ! Copy R and Q**T*B to preserve inputs and initialize S do j = 1 , n r ( j : n , j ) = r ( j , j : n ) x ( j ) = r ( j , j ) wa ( j ) = qtb ( j ) end do ! LINE 20 ! Eliminate the diagonal matrix D using a Givens rotation do j = 1 , n ! Prepare the row of D to be eliminated, locating the diagonal ! element using P from the QR factorization l = ipvt ( j ) if ( diag ( l ) /= zero ) then sdiag ( j : n ) = zero sdiag ( j ) = diag ( l ) ! The transformations to eliminate the row of D modify only a ! single element of Q**T * B beyond the first N, which is ! initially zero. qtbpj = zero do k = j , n ! Determine a Givens rotation which eliminates the ! appropriate element in the current row of D if ( sdiag ( k ) == zero ) cycle if ( abs ( r ( k , k )) < abs ( sdiag ( k ))) then ctan = r ( k , k ) / sdiag ( k ) sn = half / sqrt ( qtr + qtr * ctan ** 2 ) cs = sn * ctan else tn = sdiag ( k ) / r ( k , k ) cs = half / sqrt ( qtr + qtr * tn ** 2 ) sn = cs * tn end if ! Compute the modified diagonal element of R and the ! modified element of Q**T * B r ( k , k ) = cs * r ( k , k ) + sn * sdiag ( k ) temp = cs * wa ( k ) + sn * qtbpj qtbpj = - sn * wa ( k ) + cs * qtbpj wa ( k ) = temp ! Accumulate the transformation in the row of S kp1 = k + 1 if ( n < kp1 ) cycle do i = kp1 , n temp = cs * r ( i , k ) + sn * sdiag ( i ) sdiag ( i ) = - sn * r ( i , k ) + cs * sdiag ( i ) r ( i , k ) = temp end do ! LINE 60 end do ! LINE 80 end if ! Store the diagonal element of S and restore the corresponding ! diagonal element of R sdiag ( j ) = r ( j , j ) r ( j , j ) = x ( j ) end do ! LINE 100 ! Solve the triangular system.  If the system is singular, then obtain a ! least-squares solution nsing = n do j = 1 , n if ( sdiag ( j ) == zero . and . nsing == n ) nsing = j - 1 if ( nsing < n ) wa ( j ) = zero end do ! LINE 110 if ( nsing >= 1 ) then do k = 1 , nsing j = nsing - k + 1 sm = zero jp1 = j + 1 if ( nsing >= jp1 ) then sm = dot_product ( r ( jp1 : nsing , j ), wa ( jp1 : nsing )) end if wa ( j ) = ( wa ( j ) - sm ) / sdiag ( j ) end do ! LINE 140 end if ! Permute the components of Z back to components of X do j = 1 , n l = ipvt ( j ) x ( l ) = wa ( j ) end do ! LINE 160 end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\nonlin_least_squares.f90.html"},{"title":"nonlin_linesearch.f90 – NONLIN","text":"Contents Modules nonlin_linesearch Source Code nonlin_linesearch.f90 Source Code ! REFERENCES ! - https://scicomp.stackexchange.com/questions/26330/backtracking-armijo-line-search-algorithm ! - https://ctk.math.ncsu.edu/ module nonlin_linesearch use , intrinsic :: iso_fortran_env , only : int32 , real64 use nonlin_error_handling use nonlin_types use nonlin_multi_eqn_mult_var use nonlin_multi_var use ferror , only : errors implicit none private public :: line_search public :: limit_search_vector ! ****************************************************************************** ! TYPES ! ------------------------------------------------------------------------------ type line_search !! Defines a type capable of performing an inexact, backtracking line !! search to find a point as far along the specified direction vector !! that is usable for unconstrained minimization problems. !! !! See Also: !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Backtracking_line_search) !! !! - [Oxfford Lecture Notes](https://people.maths.ox.ac.uk/hauser/hauser_lecture2.pdf) !! !! - [Wolfram](https://reference.wolfram.com/language/tutorial/UnconstrainedOptimizationLineSearchMethods.html) !! !! - [Numerical Recipes](http://numerical.recipes/) integer ( int32 ), private :: m_maxEval = 100 !! The maximum number of function evaluations allowed during a !! single line search. real ( real64 ), private :: m_alpha = 1.0d-4 !! Defines the scaling of the product of the gradient and direction !! vectors such that  f(\\vec{x} + \\lambda \\vec{p}) <= !! f(\\vec{x}) + \\lambda \\alpha \\vec{p}&#94;{T} \\vec{g}  where !! \\vec{p} is the search direction vector, \\vec{g} is the !! gradient vector, and \\lambda is the scaling factor.  The !! parameter must exist on the set (0, 1).  A value of 1e-4 is !! typically a good starting point. real ( real64 ), private :: m_factor = 0.1d0 !! Defines a minimum factor X used to determine a minimum value !! \\lambda where \\lambda defines the distance along the !! line search direction assuming a value of one means the full !! length of the direction vector is traversed.  As such, the value !! must exist on the set (0, 1); however, for practical !! considerations, the minimum value should be limited to 0.1 such !! that the value must exist on the set [0.1, 1). contains procedure , public :: get_max_fcn_evals => ls_get_max_eval procedure , public :: set_max_fcn_evals => ls_set_max_eval procedure , public :: get_scaling_factor => ls_get_scale procedure , public :: set_scaling_factor => ls_set_scale procedure , public :: get_distance_factor => ls_get_dist procedure , public :: set_distance_factor => ls_set_dist generic , public :: search => ls_search_mimo , ls_search_miso procedure :: ls_search_mimo procedure :: ls_search_miso end type contains ! ****************************************************************************** ! LINE_SEARCH MEMBERS ! ------------------------------------------------------------------------------ pure function ls_get_max_eval ( this ) result ( n ) !! Gets the maximum number of function evaluations allowed during a !! single line search. class ( line_search ), intent ( in ) :: this !! The [[line_search]] object. integer ( int32 ) :: n !! The maximum number of function evaluations. n = this % m_maxEval end function ! -------------------- subroutine ls_set_max_eval ( this , x ) !! Sets the maximum number of function evaluations allowed during a !! single line search. class ( line_search ), intent ( inout ) :: this !! The [[line_search]] object. integer ( int32 ), intent ( in ) :: x !! The maximum number of function evaluations. this % m_maxEval = x end subroutine ! ------------------------------------------------------------------------------ pure function ls_get_scale ( this ) result ( x ) !! Gets the scaling of the product of the gradient and direction !! vectors \\alpha such that  f(\\vec{x} + \\lambda \\vec{p}) \\le !! f(\\vec{x}) + \\lambda \\alpha \\vec{p}&#94;{T} \\vec{g} , where \\vec{p} !! is the search direction vector, \\vec{g} is the gradient vector, !! and \\lambda is the scaling factor. class ( line_search ), intent ( in ) :: this !! The [[line_search]] object. real ( real64 ) :: x !! The scaling factor. x = this % m_alpha end function ! -------------------- subroutine ls_set_scale ( this , x ) !! Sets the scaling of the product of the gradient and direction !! vectors \\alpha such that  f(\\vec{x} + \\lambda \\vec{p}) \\le !! f(\\vec{x}) + \\lambda \\alpha \\vec{p}&#94;{T} \\vec{g} , where \\vec{p} !! is the search direction vector, \\vec{g} is the gradient vector, !! and \\lambda is the scaling factor. class ( line_search ), intent ( inout ) :: this !! The [[line_search]] object. real ( real64 ), intent ( in ) :: x !! The scaling factor. this % m_alpha = x end subroutine ! ------------------------------------------------------------------------------ pure function ls_get_dist ( this ) result ( x ) !! Gets a distance factor defining the minimum distance along the !! search direction vector is practical. class ( line_search ), intent ( in ) :: this !! The [[line_search]] object. real ( real64 ) :: x !! The distance factor.  A value of 1 indicates the full length !! of the vector. x = this % m_factor end function ! -------------------- subroutine ls_set_dist ( this , x ) !! Sets a distance factor defining the minimum distance along the !! search direction vector is practical. class ( line_search ), intent ( inout ) :: this !! The [[line_search]] object. real ( real64 ), intent ( in ) :: x !! The distance factor.  A value of 1 indicates the full length !! of the vector.  Notice, this value is restricted to lie in the !! set [0.1, 1.0). if ( x <= 0.0d0 ) then this % m_factor = 0.1d0 else if ( x >= 1.0d0 ) then this % m_factor = 0.99d0 else this % m_factor = x end if end subroutine ! ------------------------------------------------------------------------------ subroutine ls_search_mimo ( this , fcn , xold , grad , dir , x , fvec , fold , fx , & ib , err ) !! Utilizes an inexact, backtracking line search to find a point as !! far along the specified direction vector that is usable for !! unconstrained minimization problems. class ( line_search ), intent ( in ) :: this !! The [[line_search]] object. class ( vecfcn_helper ), intent ( in ) :: fcn !! A [[vecfcn_helper]] object containing the system of equations. real ( real64 ), intent ( in ), dimension (:) :: xold !! An N-element array defining the initial point, where N is the !! number of variables. real ( real64 ), intent ( in ), dimension (:) :: grad !! An N-element array defining the gradient of fcn evaluated at !! xold. real ( real64 ), intent ( in ), dimension (:) :: dir !! An N-element array defining the search direction. real ( real64 ), intent ( out ), dimension (:) :: x !! An N-element array where the updated solution point will be !! written. real ( real64 ), intent ( out ), dimension (:) :: fvec !! An M-element array containing the M equation values evaluated at !! x, where M is the number of equations. real ( real64 ), intent ( in ), optional :: fold !! An optional input that provides the value resulting from: !!  \\frac{1}{2} \\vec{f_{old}} \\cdot \\vec{f_{old}} .  If not !! provided, fcn is evalauted at xold, and the aforementioned !! relationship is computed. real ( real64 ), intent ( out ), optional :: fx !! The result of the operation:  \\frac{1}{2} \\vec{f} \\cdot !! \\vec{f} . type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: p5 = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 real ( real64 ), parameter :: three = 3.0d0 ! Local Variables logical :: xcnvrg , fcnvrg integer ( int32 ) :: i , m , n , neval , niter , flag , maxeval real ( real64 ) :: alam , alam1 , alamin , f1 , slope , temp , test , tmplam , & alpha , tolx , lambdamin , f , fo class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 128 ) :: errmsg ! Initialization xcnvrg = . false . fcnvrg = . false . neval = 0 niter = 0 m = fcn % get_equation_count () n = fcn % get_variable_count () tolx = two * epsilon ( tolx ) alpha = this % m_alpha lambdamin = this % m_factor maxeval = this % m_maxEval if ( present ( fx )) fx = zero if ( present ( ib )) then ib % iter_count = niter ib % fcn_count = neval ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = . false . end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Checking if (. not . fcn % is_fcn_defined ()) then ! ERROR: No function is defined call errmgr % report_error ( \"ls_search_mimo\" , & \"No function has been defined.\" , & NL_INVALID_OPERATION_ERROR ) return end if flag = 0 if ( size ( xold ) /= n ) then flag = 3 else if ( size ( grad ) /= n ) then flag = 4 else if ( size ( dir ) /= n ) then flag = 5 else if ( size ( x ) /= n ) then flag = 6 else if ( size ( fvec ) /= m ) then flag = 7 end if if ( flag /= 0 ) then ! One of the input arrays is not sized correctly write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"ls_search_mimo\" , trim ( errmsg ), & NL_ARRAY_SIZE_ERROR ) return end if ! Compute 1/2 F * F (* = dot product) if not provided if ( present ( fold )) then fo = fold else ! Evaluate the function, and compute the dot product call fcn % fcn ( xold , fvec ) fo = p5 * dot_product ( fvec , fvec ) neval = neval + 1 end if ! Compute the slope parameter slope = dot_product ( grad , dir ) if ( slope >= zero ) then ! ERROR: The slope should not be pointing uphill - invalid direction call errmgr % report_error ( \"ls_search_mimo\" , & \"The search direction vector appears to be pointing in \" // & \"an uphill direction -  away from a minimum.\" , & NL_DIVERGENT_BEHAVIOR_ERROR ) return end if ! Compute the minimum lambda value (length along the search direction) test = zero do i = 1 , n temp = abs ( dir ( i )) / max ( abs ( xold ( i )), one ) if ( temp > test ) test = temp end do alamin = tolx / test alam = one ! Iteration Loop flag = 0 ! Used to check for convergence errors do ! Step along the specified direction by the amount ALAM x = xold + alam * dir call fcn % fcn ( x , fvec ) f = p5 * dot_product ( fvec , fvec ) neval = neval + 1 niter = niter + 1 ! Check the step if ( alam < alamin ) then ! Either the solution has converged due to negligible change in ! the root values, or the line search may have fully ! backtracked.  In the event the solution fully backtracked, ! we'll issue a warning to inform the user of the potential ! issue. if ( norm2 ( x - xold ) == zero ) then ! The line search fully backtracked call errmgr % report_warning ( \"ls_search_mimo\" , & \"The line search appears to have fully \" // & \"backtracked.  As such, check results carefully, \" // & \"and/or consider attempting the solve without \" // & \"the line search.\" , & NL_CONVERGENCE_ERROR ) end if x = xold xcnvrg = . true . exit else if ( f <= fo + alpha * alam * slope ) then ! The function has converged fcnvrg = . true . exit else ! Convergence has not yet occurred, continue backtracking tmplam = min_backtrack_search ( niter , fo , f , f1 , alam , & alam1 , slope ) end if ! Set up parameters for the cubic model as we've already been ! through once with the quadratic model without success. alam1 = alam f1 = f alam = max ( tmplam , lambdamin * alam ) ! Ensure we haven't performed too many function evaluations if ( neval >= maxeval ) then ! ERROR: Too many function evaluations flag = 1 exit end if end do if ( present ( fx )) fx = f ! Report out iteration statistics if ( present ( ib )) then ib % iter_count = niter ib % fcn_count = neval ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = . false . end if ! Check for convergence issues if ( flag /= 0 ) then write ( errmsg , 100 ) \"The line search failed to \" // & \"converge.  Function evaluations performed: \" , neval , \".\" call errmgr % report_error ( \"ls_search_mimo\" , trim ( errmsg ), & NL_CONVERGENCE_ERROR ) end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine ls_search_miso ( this , fcn , xold , grad , dir , x , fold , fx , & ib , err ) !! Utilizes an inexact, backtracking line search to find a point as far !! along the specified direction vector that is usable for unconstrained !! minimization problems. class ( line_search ), intent ( in ) :: this !! The [[line_search]] object. class ( fcnnvar_helper ), intent ( in ) :: fcn !! A [[fcnnvar_helper]] object containing the system of equations. real ( real64 ), intent ( in ), dimension (:) :: xold !! An N-element array defining the initial point, where N is the !! number of variables. real ( real64 ), intent ( in ), dimension (:) :: grad !! An N-element array defining the gradient of fcn evaluated at !! xold. real ( real64 ), intent ( in ), dimension (:) :: dir !! An N-element array defining the search direction. real ( real64 ), intent ( out ), dimension (:) :: x !! An N-element array where the updated solution point will be !! written. real ( real64 ), intent ( in ), optional :: fold !! An optional input that provides the function value at xold.  If !! not provided, fcn is evalauted at xold. real ( real64 ), intent ( out ), optional :: fx !! The value of the function as evaluated at x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: p5 = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 real ( real64 ), parameter :: three = 3.0d0 ! Local Variables logical :: xcnvrg , fcnvrg integer ( int32 ) :: i , n , neval , niter , flag , maxeval real ( real64 ) :: alam , alam1 , alamin , f1 , slope , temp , test , tmplam , & alpha , tolx , lambdamin , f , fo class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 128 ) :: errmsg ! Initialization xcnvrg = . false . fcnvrg = . false . neval = 0 niter = 0 n = fcn % get_variable_count () tolx = two * epsilon ( tolx ) alpha = this % m_alpha lambdamin = this % m_factor maxeval = this % m_maxEval if ( present ( fx )) fx = zero if ( present ( ib )) then ib % iter_count = niter ib % fcn_count = neval ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = . false . end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Checking if (. not . fcn % is_fcn_defined ()) then ! ERROR: No function is defined call errmgr % report_error ( \"ls_search_miso\" , & \"No function has been defined.\" , & NL_INVALID_OPERATION_ERROR ) return end if flag = 0 if ( size ( xold ) /= n ) then flag = 3 else if ( size ( grad ) /= n ) then flag = 4 else if ( size ( dir ) /= n ) then flag = 5 else if ( size ( x ) /= n ) then flag = 6 end if if ( flag /= 0 ) then ! One of the input arrays is not sized correctly write ( errmsg , 100 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"ls_search_miso\" , trim ( errmsg ), & NL_ARRAY_SIZE_ERROR ) return end if ! Establish the \"old\" function value if ( present ( fold )) then fo = fold else ! Evaluate the function fo = fcn % fcn ( xold ) neval = neval + 1 end if ! Compute the slope parameter slope = dot_product ( grad , dir ) if ( slope >= zero ) then ! ERROR: The slope should not be pointing uphill - invalid direction call errmgr % report_error ( \"ls_search_miso\" , & \"The search direction vector appears to be pointing in \" // & \"an uphill direction -  away from a minimum.\" , & NL_DIVERGENT_BEHAVIOR_ERROR ) return end if ! Compute the minimum lambda value (length along the search direction) test = zero do i = 1 , n temp = abs ( dir ( i )) / max ( abs ( xold ( i )), one ) if ( temp > test ) test = temp end do alamin = tolx / test alam = one ! Iteration Loop flag = 0 ! Used to check for convergence errors do ! Step along the specified direction by the amount ALAM x = xold + alam * dir f = fcn % fcn ( x ) neval = neval + 1 niter = niter + 1 ! Check the step if ( alam < alamin ) then ! Either the solution has converged due to negligible change in ! the root values, or the line search may have fully ! backtracked.  In the event the solution fully backtracked, ! we'll issue a warning to inform the user of the potential ! issue. if ( norm2 ( x - xold ) == zero ) then ! The line search fully backtracked call errmgr % report_warning ( \"ls_search_miso\" , & \"The line search appears to have fully \" // & \"backtracked.  As such, check results carefully, \" // & \"and/or consider attempting the solve without \" // & \"the line search.\" , & NL_CONVERGENCE_ERROR ) end if x = xold xcnvrg = . true . exit else if ( f <= fo + alpha * alam * slope ) then ! The function has converged fcnvrg = . true . exit else ! Convergence has not yet occurred, continue backtracking tmplam = min_backtrack_search ( niter , fo , f , f1 , alam , & alam1 , slope ) end if ! Set up parameters for the cubic model as we've already been ! through once with the quadratic model without success. alam1 = alam f1 = f alam = max ( tmplam , lambdamin * alam ) ! Ensure we haven't performed too many function evaluations if ( neval >= maxeval ) then ! ERROR: Too many function evaluations flag = 1 exit end if end do if ( present ( fx )) fx = f ! Report out iteration statistics if ( present ( ib )) then ib % iter_count = niter ib % fcn_count = neval ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = . false . end if ! Check for convergence issues if ( flag /= 0 ) then write ( errmsg , 100 ) \"The line search failed to \" // & \"converge.  Function evaluations performed: \" , neval , \".\" call errmgr % report_error ( \"ls_search_miso\" , trim ( errmsg ), & NL_CONVERGENCE_ERROR ) end if ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ pure function min_backtrack_search ( mode , f0 , f , f1 , alam , alam1 , & slope ) result ( lam ) !! Minimizes either the quadratic or cubic representation for a !! backtracking-type line search. integer ( int32 ), intent ( in ) :: mode !! Set to 1 to apply the quadratic model; else, any other value !! will apply the cubic model. real ( real64 ), intent ( in ) :: f0 !! The previous function value. real ( real64 ), intent ( in ) :: f !! The current function value. real ( real64 ), intent ( in ) :: f1 !! The predicted function value. real ( real64 ), intent ( in ) :: alam !! The step length scaling factor at f. real ( real64 ), intent ( in ) :: alam1 !! The step length scaling factor at f1. real ( real64 ), intent ( in ) :: slope !! The slope of the direction vector. real ( real64 ) :: lam !! The new step length scaling factor. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: p5 = 0.5d0 real ( real64 ), parameter :: two = 2.0d0 real ( real64 ), parameter :: three = 3.0d0 ! Local Variables real ( real64 ) :: rhs1 , rhs2 , a , b , disc ! Process if ( mode == 1 ) then ! Use a quadratic function approximation lam = - slope / ( two * ( f - f0 - slope )) else ! Use a cubic function rhs1 = f - f0 - alam * slope rhs2 = f1 - f0 - alam1 * slope a = ( rhs1 / alam ** 2 - rhs2 / alam1 ** 2 ) / ( alam - alam1 ) b = ( - alam1 * rhs1 / alam ** 2 + alam * rhs2 / alam1 ** 2 ) / & ( alam - alam1 ) if ( a == zero ) then lam = - slope / ( two * b ) else disc = b ** 2 - three * a * slope if ( disc < zero ) then lam = p5 * alam else if ( b <= zero ) then lam = ( - b + sqrt ( disc )) / ( three * a ) else lam = - slope / ( b + sqrt ( disc )) end if end if if ( lam > p5 * alam ) lam = p5 * alam end if end function ! ------------------------------------------------------------------------------ subroutine limit_search_vector ( x , lim ) !! Provides a means of scaling the length of the search direction !! vector. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the search direction vector.  On output, the search !! direction vector limited in length to that specified by lim. !!  If the vector is originally shorter than the limit length, no !! change is made. real ( real64 ), intent ( in ) :: lim !! The length limit value. ! Local Variables real ( real64 ) :: mag ! Process mag = norm2 ( x ) if ( mag == 0.0d0 ) return if ( mag > lim ) x = ( lim / mag ) * x end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\nonlin_linesearch.f90.html"},{"title":"nonlin_multi_eqn_mult_var.f90 – NONLIN","text":"Contents Modules nonlin_multi_eqn_mult_var Source Code nonlin_multi_eqn_mult_var.f90 Source Code module nonlin_multi_eqn_mult_var use iso_fortran_env use nonlin_types use ferror implicit none private public :: vecfcn public :: jacobianfcn public :: vecfcn_helper public :: equation_solver public :: nonlin_solver interface subroutine vecfcn ( x , f ) !! Describes an M-element vector-valued function of N-variables. use , intrinsic :: iso_fortran_env , only : real64 real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the independent variables. real ( real64 ), intent ( out ), dimension (:) :: f !! An M-element array that, on output, contains the values !! of the M functions. end subroutine subroutine jacobianfcn ( x , jac ) !! Describes a routine capable of computing the Jacobian matrix !! of M functions of N unknowns. use , intrinsic :: iso_fortran_env , only : real64 real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the independent variables. real ( real64 ), intent ( out ), dimension (:,:) :: jac !! An M-by-N matrix where the Jacobian will be written. end subroutine end interface type vecfcn_helper !! Defines a type capable of encapsulating a system of nonlinear !! equations of the form: F(X) = 0.  This type is used to establish the !! system of equations to solve, and provides a means for computing !! the Jacobian matrix for the system of equations, and any other !! ancillary operations that may be needed by the solver. procedure ( vecfcn ), private , pointer , nopass :: m_fcn => null () !! A pointer to the target vecfcn routine. procedure ( jacobianfcn ), private , pointer , nopass :: m_jac => null () !! A pointer to the jacobian routine - null if no routine is !! supplied. integer ( int32 ), private :: m_nfcn = 0 !! The number of functions in m_fcn. integer ( int32 ) :: m_nvar = 0 !! The number of variables in m_fcn. contains procedure , public :: set_fcn => vfh_set_fcn procedure , public :: set_jacobian => vfh_set_jac procedure , public :: is_fcn_defined => vfh_is_fcn_defined procedure , public :: is_jacobian_defined => vfh_is_jac_defined procedure , public :: fcn => vfh_fcn procedure , public :: jacobian => vfh_jac_fcn procedure , public :: get_equation_count => vfh_get_nfcn procedure , public :: get_variable_count => vfh_get_nvar end type type , abstract :: equation_solver !! A base class for various solvers of nonlinear systems of equations. integer ( int32 ), private :: m_maxEval = 100 !! The maximum number of function evaluations allowed per solve. real ( real64 ), private :: m_fcnTol = 1.0d-8 !! The convergence criteria on function values. real ( real64 ), private :: m_xtol = 1.0d-12 !! The convergence criteria on change in variable values. real ( real64 ), private :: m_gtol = 1.0d-12 !! The convergence criteria for the slope of the gradient vector. logical , private :: m_printStatus = . false . !! Set to true to print iteration status; else, false. contains procedure , public :: get_max_fcn_evals => es_get_max_eval procedure , public :: set_max_fcn_evals => es_set_max_eval procedure , public :: get_fcn_tolerance => es_get_fcn_tol procedure , public :: set_fcn_tolerance => es_set_fcn_tol procedure , public :: get_var_tolerance => es_get_var_tol procedure , public :: set_var_tolerance => es_set_var_tol procedure , public :: get_gradient_tolerance => es_get_grad_tol procedure , public :: set_gradient_tolerance => es_set_grad_tol procedure , public :: get_print_status => es_get_print_status procedure , public :: set_print_status => es_set_print_status procedure ( nonlin_solver ), deferred , public , pass :: solve end type interface subroutine nonlin_solver ( this , fcn , x , fvec , ib , err ) !! Describes the interface of a nonlinear equation solver. use , intrinsic :: iso_fortran_env , only : real64 use nonlin_types , only : iteration_behavior use ferror , only : errors import equation_solver import vecfcn_helper class ( equation_solver ), intent ( inout ) :: this !! The [[equation_solver]]-based object. class ( vecfcn_helper ), intent ( in ) :: fcn !! The [[vecfcn_helper]] object containing the equations to !! solve. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, an N-element array containing an initial estimate !! to the solution.  On output, the updated solution estimate. !! N is the number of variables. real ( real64 ), intent ( out ), dimension (:) :: fvec !! An M-element array that, on output, will contain the values !! of each equation as evaluated at the variable values given !! in x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. end subroutine end interface contains ! ****************************************************************************** ! VECFCN_HELPER ! ------------------------------------------------------------------------------ subroutine vfh_set_fcn ( this , fcn , nfcn , nvar ) !! Establishes a pointer to the routine containing the system of !! equations to solve. class ( vecfcn_helper ), intent ( inout ) :: this !! The [[vecfcn_helper]] object. procedure ( vecfcn ), intent ( in ), pointer :: fcn !! The function pointer. integer ( int32 ), intent ( in ) :: nfcn !! The number of functions. integer ( int32 ), intent ( in ) :: nvar !! The number of variables. this % m_fcn => fcn this % m_nfcn = nfcn this % m_nvar = nvar end subroutine ! ------------------------------------------------------------------------------ subroutine vfh_set_jac ( this , jac ) !! Establishes a pointer to the routine for computing the !! Jacobian matrix of the system of equations.  If no routine is !! defined, the Jacobian matrix will be computed numerically (this is !! the default state). class ( vecfcn_helper ), intent ( inout ) :: this !! The [[vecfcn_helper]] object. procedure ( jacobianfcn ), intent ( in ), pointer :: jac !! The function pointer. this % m_jac => jac end subroutine ! ------------------------------------------------------------------------------ function vfh_is_fcn_defined ( this ) result ( x ) !! Tests if the pointer to the subroutine containing the system !! of equations to solve has been assigned. class ( vecfcn_helper ), intent ( in ) :: this !! The [[vecfcn_helper]] object. logical :: x !! Returns true if the pointer has been assigned; else, false. x = associated ( this % m_fcn ) end function ! ------------------------------------------------------------------------------ function vfh_is_jac_defined ( this ) result ( x ) !! Tests if the pointer to the Jacobian calculation routine has been !! defined. class ( vecfcn_helper ), intent ( in ) :: this !! The [[vecfcn_helper]] object. logical :: x !! Returns true if the pointer has been assigned; else, false. x = associated ( this % m_jac ) end function ! ------------------------------------------------------------------------------ subroutine vfh_fcn ( this , x , f ) !! Executes the routine containing the system of equations to !! solve.  No action is taken if the pointer to the subroutine has not !! been defined. class ( vecfcn_helper ), intent ( in ) :: this !! The [[vecfcn_helper]] object. real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the independent variables. real ( real64 ), intent ( out ), dimension (:) :: f !! An M-element array that, on output, contains the values !! of the M functions. if ( this % is_fcn_defined ()) then call this % m_fcn ( x , f ) end if end subroutine ! ------------------------------------------------------------------------------ subroutine vfh_jac_fcn ( this , x , jac , fv , work , olwork , err ) !! Executes the routine containing the Jacobian matrix if !! supplied.  If not supplied, the Jacobian is computed via finite !! differences. class ( vecfcn_helper ), intent ( in ) :: this !! The [[vecfcn_helper]] object. real ( real64 ), intent ( inout ), dimension (:) :: x !! An N-element array containing the independent variables defining !! the point about which the derivatives will be calculated. real ( real64 ), intent ( out ), dimension (:,:) :: jac !! An M-by-N matrix where, on output, the Jacobian will !! be written. real ( real64 ), intent ( in ), dimension (:), optional , target :: fv !! An optional M-element array containing the function values at x. !! If not supplied, the function values are computed at x. real ( real64 ), intent ( out ), dimension (:), optional , target :: work !! An optional input, that if provided, prevents any local memory !! allocation.  If not provided, the memory required is allocated !! within.  If provided, the length of the array must be at least !! olwork.  Notice, a workspace array is only utilized if the user !! does not provide a routine for computing the Jacobian. integer ( int32 ), intent ( out ), optional :: olwork !! An optional output used to determine workspace size. If supplied, !! the routine determines the optimal size for work, and returns !! without performing any actual calculations. integer ( int32 ), intent ( out ), optional :: err !! An optional integer output that can be used to determine !! error status.  If not used, and an error is encountered, the !! routine simply returns silently.  If used, the following error !! codes identify error status: !! !!  - 0: No error has occurred. !! !!  - n: A positive integer denoting the index of an invalid input. !! !!  - -1: Indicates internal memory allocation failed. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: j , m , n , lwork , flag real ( real64 ) :: eps , epsmch , h , temp real ( real64 ), pointer , dimension (:) :: fptr , f1ptr real ( real64 ), allocatable , target , dimension (:) :: wrk ! Initialization if ( present ( err )) err = 0 ! m = this%m_nfcn ! n = this%m_nvar m = this % get_equation_count () n = this % get_variable_count () ! Input Checking flag = 0 if ( size ( x ) /= n ) then flag = 2 else if ( size ( jac , 1 ) /= m . or . size ( jac , 2 ) /= n ) then flag = 3 end if if ( flag /= 0 ) then ! ERROR: Incorrectly sized input arrays if ( present ( err )) err = flag return end if ! Process if (. not . this % is_fcn_defined ()) return if ( associated ( this % m_jac )) then ! Workspace Query if ( present ( olwork )) then olwork = 0 return end if ! Call the user-defined Jacobian routine call this % m_jac ( x , jac ) else ! Compute the Jacobian via finite differences if ( present ( fv )) then lwork = m else lwork = 2 * m end if if ( present ( olwork )) then ! The user is just making a workspace query.  Simply return the ! workspace length, and exit the routine. olwork = lwork return end if ! Local Memory Allocation if ( present ( work )) then if ( size ( work ) < lwork ) then ! ERROR: Workspace is too small if ( present ( err )) err = 5 return end if f1ptr => work ( 1 : m ) if ( present ( fv )) then if ( size ( fv ) < m ) then ! ERROR: Function vector too small if ( present ( err )) err = 4 return end if fptr => fv ( 1 : m ) else fptr => work ( m + 1 : 2 * m ) call this % fcn ( x , fptr ) end if else allocate ( wrk ( lwork ), stat = flag ) if ( flag /= 0 ) then ! ERROR: Memory issues if ( present ( err )) err = - 1 return end if f1ptr => wrk ( 1 : m ) if ( present ( fv )) then fptr => fv ( 1 : m ) else fptr => wrk ( m + 1 : 2 * m ) call this % fcn ( x , fptr ) end if end if ! Establish step size factors epsmch = epsilon ( epsmch ) eps = sqrt ( epsmch ) ! Compute the derivatives via finite differences do j = 1 , n temp = x ( j ) h = eps * abs ( temp ) if ( h == zero ) h = eps x ( j ) = temp + h call this % fcn ( x , f1ptr ) x ( j ) = temp jac (:, j ) = ( f1ptr - fptr ) / h end do end if end subroutine ! ------------------------------------------------------------------------------ function vfh_get_nfcn ( this ) result ( n ) !! Gets the number of equations in this system. class ( vecfcn_helper ), intent ( in ) :: this !! The [[vecfcn_helper]] object. integer ( int32 ) :: n !! The function count. n = this % m_nfcn end function ! ------------------------------------------------------------------------------ function vfh_get_nvar ( this ) result ( n ) !! Gets the number of variables in this system. class ( vecfcn_helper ), intent ( in ) :: this !! The [[vecfcn_helper]] object. integer ( int32 ) :: n !! The number of variables. n = this % m_nvar end function ! ****************************************************************************** ! EQUATION_SOLVER ! ------------------------------------------------------------------------------ pure function es_get_max_eval ( this ) result ( n ) !! Gets the maximum number of function evaluations allowed during !! a single solve. class ( equation_solver ), intent ( in ) :: this !! The [[equation_solver]] object. integer ( int32 ) :: n !! The maximum number of function evaluations. n = this % m_maxEval end function ! -------------------- subroutine es_set_max_eval ( this , n ) !! Sets the maximum number of function evaluations allowed during !! a single solve. class ( equation_solver ), intent ( inout ) :: this !! The [[equation_solver]] object. integer ( int32 ), intent ( in ) :: n !! The maximum number of function evaluations. this % m_maxEval = n end subroutine ! ------------------------------------------------------------------------------ pure function es_get_fcn_tol ( this ) result ( x ) !! Gets the convergence on function value tolerance. class ( equation_solver ), intent ( in ) :: this !! The [[equation_solver]] object. real ( real64 ) :: x !! The tolerance value. x = this % m_fcnTol end function ! -------------------- subroutine es_set_fcn_tol ( this , x ) !! Sets the convergence on function value tolerance. class ( equation_solver ), intent ( inout ) :: this !! The [[equation_solver]] object. real ( real64 ), intent ( in ) :: x !! The tolerance value. this % m_fcnTol = x end subroutine ! ------------------------------------------------------------------------------ pure function es_get_var_tol ( this ) result ( x ) !! Gets the convergence on change in variable tolerance. class ( equation_solver ), intent ( in ) :: this !! The [[equation_solver]] object. real ( real64 ) :: x !! The tolerance value. x = this % m_xtol end function ! -------------------- subroutine es_set_var_tol ( this , x ) !! Sets the convergence on change in variable tolerance. class ( equation_solver ), intent ( inout ) :: this !! The [[equation_solver]] object. real ( real64 ), intent ( in ) :: x !! The tolerance value. this % m_xtol = x end subroutine ! ------------------------------------------------------------------------------ pure function es_get_grad_tol ( this ) result ( x ) !! Gets the convergence on slope of the gradient vector !! tolerance. class ( equation_solver ), intent ( in ) :: this !! The [[equation_solver]] object. real ( real64 ) :: x !! The tolerance value. x = this % m_gtol end function ! -------------------- subroutine es_set_grad_tol ( this , x ) !! Sets the convergence on slope of the gradient vector tolerance. class ( equation_solver ), intent ( inout ) :: this !! The [[equation_solver]] object. real ( real64 ), intent ( in ) :: x !! The tolerance value. this % m_gtol = x end subroutine ! ------------------------------------------------------------------------------ pure function es_get_print_status ( this ) result ( x ) !! Gets a logical value determining if iteration status should be !! printed. class ( equation_solver ), intent ( in ) :: this !! The [[equation_solver]] object. logical :: x !! True if the iteration status should be printed; else, false. x = this % m_printStatus end function ! -------------------- subroutine es_set_print_status ( this , x ) !! Sets a logical value determining if iteration status should be !! printed. class ( equation_solver ), intent ( inout ) :: this !! The [[equation_solver]] object. logical , intent ( in ) :: x !! True if the iteration status should be printed; else, false. this % m_printStatus = x end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\nonlin_multi_eqn_mult_var.f90.html"},{"title":"nonlin_multi_var.f90 – NONLIN","text":"Contents Modules nonlin_multi_var Source Code nonlin_multi_var.f90 Source Code module nonlin_multi_var use iso_fortran_env use nonlin_types use ferror implicit none private public :: fcnnvar public :: gradientfcn public :: fcnnvar_helper public :: equation_optimizer public :: nonlin_optimize_fcn interface function fcnnvar ( x ) result ( f ) !! Describes a function of N variables. use , intrinsic :: iso_fortran_env , only : real64 real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the independent variables. real ( real64 ) :: f !! The value of the function. end function subroutine gradientfcn ( x , g ) !! Describes a routine capable of computing the gradient vector !! of an equation of N variables. use , intrinsic :: iso_fortran_env , only : real64 real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the independent variables. real ( real64 ), intent ( out ), dimension (:) :: g !! An N-element array where the gradient vector will be !! written as output. end subroutine end interface type fcnnvar_helper !! Defines a type capable of encapsulating an equation of N variables. private procedure ( fcnnvar ), pointer , nopass :: m_fcn => null () !! A pointer to the target fcnnvar routine. procedure ( gradientfcn ), pointer , nopass :: m_grad => null () !! A pointer to the gradient routine. integer ( int32 ) :: m_nvar = 0 !! The number of variables in m_fcn. contains procedure , public :: fcn => fnh_fcn procedure , public :: is_fcn_defined => fnh_is_fcn_defined procedure , public :: set_fcn => fnh_set_fcn procedure , public :: get_variable_count => fnh_get_nvar procedure , public :: set_gradient_fcn => fnh_set_grad procedure , public :: is_gradient_defined => fnh_is_grad_defined procedure , public :: gradient => fnh_grad_fcn end type type , abstract :: equation_optimizer !! A base class for optimization of an equation of multiple variables. integer ( int32 ), private :: m_maxEval = 500 !! The maximum number of function evaluations allowed. real ( real64 ), private :: m_tol = 1.0d-12 !! The error tolerance used to determine convergence. logical , private :: m_printStatus = . false . !! Set to true to print iteration status; else, false. contains procedure , public :: get_max_fcn_evals => oe_get_max_eval procedure , public :: set_max_fcn_evals => oe_set_max_eval procedure , public :: get_tolerance => oe_get_tol procedure , public :: set_tolerance => oe_set_tol procedure , public :: get_print_status => oe_get_print_status procedure , public :: set_print_status => oe_set_print_status procedure ( nonlin_optimize_fcn ), deferred , public , pass :: solve end type interface subroutine nonlin_optimize_fcn ( this , fcn , x , fout , ib , err ) !! Describes the interface of a routine for optimizing an !! equation of N variables. use , intrinsic :: iso_fortran_env , only : real64 use nonlin_types , only : iteration_behavior use ferror , only : errors import equation_optimizer import fcnnvar_helper class ( equation_optimizer ), intent ( inout ) :: this !! The [[equation_optimizer]] object. class ( fcnnvar_helper ), intent ( in ) :: fcn !! The [[fcnnvar_helper]] object containing the equation to !! optimize. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the initial guess at the optimal point.  On !! output, the updated optimal point estimate. real ( real64 ), intent ( out ), optional :: fout !! An optional output, that if provided, returns the value of !! the function at x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. end subroutine end interface contains ! ****************************************************************************** ! FCNNVAR_HELPER ! ------------------------------------------------------------------------------ function fnh_fcn ( this , x ) result ( f ) !! Executes the routine containing the function to evaluate. class ( fcnnvar_helper ), intent ( in ) :: this !! The [[fcnnvar_helper]] object. real ( real64 ), intent ( in ), dimension (:) :: x !! The value of the independent variables at which the function !! should be evaluated. real ( real64 ) :: f !! The value of the function. if ( associated ( this % m_fcn )) then f = this % m_fcn ( x ) end if end function ! ------------------------------------------------------------------------------ function fnh_is_fcn_defined ( this ) result ( x ) !! Tests if the pointer to the function has been assigned. class ( fcnnvar_helper ), intent ( in ) :: this !! The [[fcnnvar_helper]] object. logical :: x !! Returns true if the pointer has been assigned; else, false. x = associated ( this % m_fcn ) end function ! ------------------------------------------------------------------------------ subroutine fnh_set_fcn ( this , fcn , nvar ) !! Establishes a pointer to the routine containing the function. class ( fcnnvar_helper ), intent ( inout ) :: this !! The [[fcnnvar_helper]] object. procedure ( fcnnvar ), intent ( in ), pointer :: fcn !! The function pointer. integer ( int32 ), intent ( in ) :: nvar !! The number of variables in the function. this % m_fcn => fcn this % m_nvar = nvar end subroutine ! ------------------------------------------------------------------------------ function fnh_get_nvar ( this ) result ( n ) !! Gets the number of variables in this system. class ( fcnnvar_helper ), intent ( in ) :: this !! The [[fcnnvar_helper]] object. integer ( int32 ) :: n !! The number of variables. n = this % m_nvar end function ! ------------------------------------------------------------------------------ subroutine fnh_set_grad ( this , fcn ) !! Establishes a pointer to the routine containing the gradient !! vector of the function. class ( fcnnvar_helper ), intent ( inout ) :: this !! The [[fcnnvar_helper]] object. procedure ( gradientfcn ), pointer , intent ( in ) :: fcn !! The pointer to the gradient routine. this % m_grad => fcn end subroutine ! ------------------------------------------------------------------------------ function fnh_is_grad_defined ( this ) result ( x ) !! Tests if the pointer to the routine containing the gradient !! has been assigned. class ( fcnnvar_helper ), intent ( in ) :: this !! The [[fcnnvar_helper]] object. logical :: x !! Returns true if the pointer has been assigned; else, false. x = associated ( this % m_grad ) end function ! ------------------------------------------------------------------------------ subroutine fnh_grad_fcn ( this , x , g , fv , err ) !! Computes the gradient of the function. class ( fcnnvar_helper ), intent ( in ) :: this !! The [[fcnnvar_helper]] object. real ( real64 ), intent ( inout ), dimension (:) :: x !! An N-element array containing the independent variables defining !! the point about which the derivatives will be calculated.  This !! array is restored upon output. real ( real64 ), intent ( out ), dimension (:) :: g !! An N-element array where the gradient will be written upon !! output. real ( real64 ), intent ( in ), optional :: fv !! An optional input providing the function value at x. integer ( int32 ), intent ( out ), optional :: err !! An optional integer output that can be used to determine error !! status.  If not used, and an error is encountered, the routine !! simply returns silently.  If used, the following error codes !! identify error status: !! !!  - 0: No error has occurred. !! !!  - n: A positive integer denoting the index of an invalid input. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: j , n , flag real ( real64 ) :: eps , epsmch , h , temp , f , f1 ! Initialization if ( present ( err )) err = 0 ! n = this%m_nvar n = this % get_variable_count () ! Input Checking flag = 0 if ( size ( x ) /= n ) then flag = 2 else if ( size ( g ) /= n ) then flag = 3 end if if ( flag /= 0 ) then ! ERROR: Incorrectly sized input arrays if ( present ( err )) err = flag return end if ! Process if (. not . this % is_fcn_defined ()) return if ( this % is_gradient_defined ()) then ! Call the user-defined gradient routine call this % m_grad ( x , g ) else ! Compute the gradient via finite differences if ( present ( fv )) then f = fv else f = this % fcn ( x ) end if ! Establish step size factors epsmch = epsilon ( epsmch ) eps = sqrt ( epsmch ) ! Compute the derivatives do j = 1 , n temp = x ( j ) h = eps * abs ( temp ) if ( h == zero ) h = eps x ( j ) = temp + h f1 = this % fcn ( x ) x ( j ) = temp g ( j ) = ( f1 - f ) / h end do end if end subroutine ! ****************************************************************************** ! EQUATION_OPTIMIZER ! ------------------------------------------------------------------------------ pure function oe_get_max_eval ( this ) result ( n ) class ( equation_optimizer ), intent ( in ) :: this !! The [[equation_optimizer]] object. integer ( int32 ) :: n !! The maximum number of function evaluations. n = this % m_maxEval end function ! -------------------- subroutine oe_set_max_eval ( this , n ) class ( equation_optimizer ), intent ( inout ) :: this !! The [[equation_optimizer]] object. integer ( int32 ), intent ( in ) :: n !! The maximum number of function evaluations. this % m_maxEval = n end subroutine ! ------------------------------------------------------------------------------ pure function oe_get_tol ( this ) result ( x ) class ( equation_optimizer ), intent ( in ) :: this !! The [[equation_optimizer]] object. real ( real64 ) :: x !! The tolerance. x = this % m_tol end function ! -------------------- subroutine oe_set_tol ( this , x ) class ( equation_optimizer ), intent ( inout ) :: this !! The [[equation_optimizer]] object. real ( real64 ), intent ( in ) :: x !! The tolerance. this % m_tol = x end subroutine ! ------------------------------------------------------------------------------ pure function oe_get_print_status ( this ) result ( x ) class ( equation_optimizer ), intent ( in ) :: this !! The [[equation_optimizer]] object. logical :: x !! True if the iteration status should be printed; else, false. x = this % m_printStatus end function ! -------------------- subroutine oe_set_print_status ( this , x ) class ( equation_optimizer ), intent ( inout ) :: this !! The [[equation_optimizer]] object. logical , intent ( in ) :: x !! True if the iteration status should be printed; else, false. this % m_printStatus = x end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\nonlin_multi_var.f90.html"},{"title":"nonlin_optimize.f90 – NONLIN","text":"Contents Modules nonlin_optimize Source Code nonlin_optimize.f90 Source Code ! nonlin_optimize.f90 ! REF: ! http://ab-initio.mit.edu/wiki/index.php/NLopt_Algorithms#Nelder-Mead_Simplex ! http://ab-initio.mit.edu/wiki/index.php/NLopt_Algorithms ! https://scicomp.stackexchange.com/questions/14787/fortran-library-for-minimization-or-maximization-of-functions-optimization-prob ! http://ab-initio.mit.edu/wiki/index.php/NLopt module nonlin_optimize use iso_fortran_env use ferror use nonlin_linesearch use nonlin_error_handling use nonlin_multi_var use nonlin_types use linalg , only : rank1_update , tri_mtx_mult , cholesky_rank1_update , & cholesky_rank1_downdate , solve_cholesky use linalg_errors , only : LA_MATRIX_FORMAT_ERROR implicit none private public :: nelder_mead public :: line_search_optimizer public :: bfgs type , extends ( equation_optimizer ) :: nelder_mead !! Defines a solver based upon Nelder and Mead's simplex algorithm !! for minimization of functions of multiple variables. real ( real64 ), private , allocatable , dimension (:,:) :: m_simplex !! The simplex vertices. real ( real64 ), private :: m_initSize = 1.0d0 !! A scaling parameter used to define the size of the simplex in !! each coordinate direction. contains procedure , public :: solve => nm_solve procedure , public :: get_simplex => nm_get_simplex procedure , public :: set_simplex => nm_set_simplex procedure , public :: get_initial_size => nm_get_size procedure , public :: set_initial_size => nm_set_size procedure , private :: extrapolate => nm_extrapolate end type type , abstract , extends ( equation_optimizer ) :: line_search_optimizer !! A class describing equation optimizers that use a line search !! algorithm to improve convergence behavior. class ( line_search ), private , allocatable :: m_lineSearch !! The line search object. logical , private :: m_useLineSearch = . true . !! Set to true if a line search should be used regardless of the !! status of m_lineSearch real ( real64 ), private :: m_xtol = 1.0d-12 !! The convergence criteria on change in variable. contains procedure , public :: get_line_search => lso_get_line_search procedure , public :: set_line_search => lso_set_line_search procedure , public :: set_default_line_search => lso_set_default procedure , public :: is_line_search_defined => & lso_is_line_search_defined procedure , public :: get_use_line_search => lso_get_use_search procedure , public :: set_use_line_search => lso_set_use_search procedure , public :: get_var_tolerance => lso_get_var_tol procedure , public :: set_var_tolerance => lso_set_var_tol end type type , extends ( line_search_optimizer ) :: bfgs !! Defines a Broyden–Fletcher–Goldfarb–Shanno (BFGS) solver for !! minimization of functions of multiple variables. !! !! See Also: !! !! - [Wikipedia - BFGS Methods](https://en.wikipedia.org/wiki/Broyden%E2%80%93Fletcher%E2%80%93Goldfarb%E2%80%93Shanno_algorithm) !! !! - [Wikipedia - Quasi-Newton Methods](https://en.wikipedia.org/wiki/Quasi-Newton_method) !! !! - [minFunc](https://www.cs.ubc.ca/~schmidtm/Software/minFunc.html) contains procedure , public :: solve => bfgs_solve end type interface subroutine DSYMV ( uplo , n , alpha , a , lda , x , incx , beta , y , incy ) use iso_fortran_env , only : int32 , real64 character , intent ( in ) :: uplo integer ( int32 ), intent ( in ) :: n , lda , incx , incy real ( real64 ), intent ( in ) :: alpha , beta , a ( lda , * ), x ( * ) real ( real64 ), intent ( inout ) :: y ( * ) end subroutine end interface contains ! ****************************************************************************** ! NELDER_MEAD ! ------------------------------------------------------------------------------ subroutine nm_solve ( this , fcn , x , fout , ib , err ) !! Utilizes the Nelder-Mead simplex method for finding a minimum !! value of the specified function. !! !! The implementation of the Nelder-Mead algorithm presented here is a !! slight modification of the original work of Nelder and Mead.  The !! Numerical Recipes implementation is also quite similar.  In fact, the !! Numerical Recipes section relating to reflection, contraction, etc. !! is leveraged for this implemetation. !! !! See Also: !! !!  - Nelder, John A.; R. Mead (1965). \"A simplex method for function !!      minimization\". Computer Journal. 7: 308–313. !! !!  - [Gao, Fuchang, Han, Lixing (2010). \"Implementing the Nelder-Mead !!      simplex algorithm with adaptive parameters.\"] !!      (http://www.webpages.uidaho.edu/~fuchang/res/ANMS.pdf) !! !!  - [Wikipedia](https://en.wikipedia.org/wiki/Nelder–Mead_method) !! !!  - [Numerical Recipes](http://numerical.recipes/) class ( nelder_mead ), intent ( inout ) :: this !! The [[nelder_mead]] object. class ( fcnnvar_helper ), intent ( in ) :: fcn !! The [[fcnnvar_helper]] object containing the equation to !! optimize. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the initial guess at the optimal point.  On output, !! the updated optimal point estimate. real ( real64 ), intent ( out ), optional :: fout !! An optional output, that if provided, returns the value of the !! function at x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: negone = - 1.0d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables logical :: buildSimplex , fcnvrg integer ( int32 ) :: i , ihi , ilo , ihi2 , ndim , npts , flag , neval , iter , & maxeval real ( real64 ) :: ftol , rtol , ftry , fsave , fval , swp real ( real64 ), allocatable , dimension (:) :: f , pcent , pmin , work class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 256 ) :: errmsg ! Initialization ndim = fcn % get_variable_count () npts = ndim + 1 buildSimplex = . true . maxeval = this % get_max_fcn_evals () ftol = this % get_tolerance () iter = 0 neval = 0 fcnvrg = . false . if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = 0 ib % gradient_count = 0 ib % converge_on_fcn = fcnvrg ib % converge_on_chng = . false . ib % converge_on_zero_diff = . false . end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if (. not . fcn % is_fcn_defined ()) then ! ERROR: No function is defined call errmgr % report_error ( \"nm_solve\" , & \"No function has been defined.\" , & NL_INVALID_OPERATION_ERROR ) return end if if ( size ( x ) /= ndim ) then write ( errmsg , 100 ) & \"It was expected to receive a coordinate vector of length \" , & ndim , \" , but a vector of length \" , size ( x ), \" was received.\" call errmgr % report_error ( \"nm_solve\" , trim ( errmsg ), & NL_INVALID_INPUT_ERROR ) return end if ! Ensure that if an initial simplex was defined, that it is ! appropriately sized.  If not, simply create a new simplex of the ! appropriate size. if ( allocated ( this % m_simplex )) then ! This matrix must be NDIM-by-NPTS if ( size ( this % m_simplex , 1 ) /= ndim . or . & size ( this % m_simplex , 2 ) /= npts ) then deallocate ( this % m_simplex ) buildSimplex = . true . else ! The simplex is appropriately sized buildSimplex = . false . end if end if ! Local Memory Allocation allocate ( f ( npts ), stat = flag ) if ( flag == 0 ) allocate ( pcent ( ndim ), stat = flag ) if ( flag == 0 ) allocate ( pmin ( ndim ), stat = flag ) if ( flag == 0 ) allocate ( work ( ndim ), stat = flag ) if ( buildSimplex . and . flag == 0 ) allocate ( this % m_simplex ( ndim , npts )) if ( flag /= 0 ) then ! ERROR: Out of memory call errmgr % report_error ( \"nm_solve\" , & \"Insufficient memory available.\" , NL_OUT_OF_MEMORY_ERROR ) return end if ! Define the initial simplex, if needed if ( buildSimplex ) then this % m_simplex (:, 1 ) = x do i = 2 , npts this % m_simplex (:, i ) = x end do do i = 1 , ndim this % m_simplex ( i , i + 1 ) = this % m_simplex ( i , i + 1 ) + this % m_initSize end do end if ! Evaluate the function at each vertex of the simplex do i = 1 , npts f ( i ) = fcn % fcn ( this % m_simplex (:, i )) end do neval = npts fval = f ( 1 ) do i = 1 , ndim pcent ( i ) = sum ( this % m_simplex ( i ,:)) end do ! Main Loop flag = 0 ! Used to check for convergence errors do ! Update the iteration counter iter = iter + 1 ! Determine the characteristics of each vertex ilo = 1 if ( f ( 1 ) > f ( 2 )) then ihi = 1 ihi2 = 2 else ihi = 2 ihi2 = 1 end if do i = 1 , npts if ( f ( i ) <= f ( ilo )) ilo = i if ( f ( i ) > f ( ihi )) then ihi2 = ihi ihi = i else if ( f ( i ) > f ( ihi2 )) then if ( i /= ihi ) ihi2 = i end if end do ! Check for convergence.  Nelder and Mead recommend using the ! following convergence test: sqrt(sum(f - favg)**2 / n); however, ! it seems that a sufficient check may be made using only the ! extreme function values of the simplex (highest and lowest valued ! points). rtol = abs ( f ( ihi ) - f ( ilo )) if ( rtol < ftol ) then swp = f ( 1 ) f ( 1 ) = f ( ilo ) f ( ilo ) = swp do i = 1 , ndim swp = this % m_simplex ( i , 1 ) this % m_simplex ( i , 1 ) = this % m_simplex ( i , ilo ) this % m_simplex ( i , ilo ) = swp x ( i ) = this % m_simplex ( i , 1 ) end do fval = f ( 1 ) fcnvrg = . true . exit end if ! Start of a new iteration by reflecting the simplex at its largest ! point. ftry = this % extrapolate ( fcn , f , pcent , ihi , negone , neval , work ) if ( ftry <= f ( ilo )) then ! The result of the reflection is better than the current ! best point.  As a result, try a factor of 2 in the reflected ! direction.  Again, the highest point is of interest. ftry = this % extrapolate ( fcn , f , pcent , ihi , two , neval , work ) else if ( ftry >= f ( ihi2 )) then ! The reflected point is worse than the second highest, so look ! for an intermediate lower point (contract the simplex) fsave = f ( ihi ) ftry = this % extrapolate ( fcn , f , pcent , ihi , half , neval , work ) if ( ftry >= fsave ) then ! Cannot improve on the high point.  Try to contract around ! the low point. do i = 1 , npts if ( i /= ilo ) then pcent = half * ( this % m_simplex (:, i ) + & this % m_simplex (:, ilo )) this % m_simplex (:, i ) = pcent f ( i ) = fcn % fcn ( pcent ) end if end do neval = neval + npts do i = 1 , ndim pcent ( i ) = sum ( this % m_simplex ( i ,:)) end do end if end if ! Print iteration status if ( this % get_print_status ()) then print * , \"\" print 101 , \"Iteration: \" , iter print 101 , \"Function Evaluations: \" , neval print 102 , \"Function Value: \" , fval print 102 , \"Convergence Parameter: \" , rtol end if ! Ensure we haven't made too many function evaluations if ( neval >= maxeval ) then flag = 1 exit end if end do ! Report out iteration statistics if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = 0 ib % gradient_count = 0 ib % converge_on_fcn = fcnvrg ib % converge_on_chng = . false . ib % converge_on_zero_diff = . false . end if ! Get the function value at the computed minimum if ( present ( fout )) fout = fval ! Check for convergence issues if ( flag /= 0 ) then write ( errmsg , 103 ) & \"The algorithm failed to converge.\" // new_line ( 'c' ) // & \"Function evaluations performed: \" , neval , new_line ( 'c' ) // & \"Convergence Parameter: \" , rtol , new_line ( 'c' ) // & \"Convergence Criteria: \" , ftol call errmgr % report_error ( \"nm_solve\" , trim ( errmsg ), & NL_CONVERGENCE_ERROR ) end if ! Formatting 100 format ( A , I0 , A , I0 , A ) 101 format ( A , I0 ) 102 format ( A , E10 . 3 ) 103 format ( A , I0 , A , E10 . 3 , A , E10 . 3 ) end subroutine ! ------------------------------------------------------------------------------ function nm_extrapolate ( this , fcn , y , pcent , ihi , fac , neval , & work ) result ( ytry ) !! Extrapolates by the specified factor through the simplex across !! from the largest point.  If the extrapolation results in a better !! estimate, the current high point is replaced with the new estimate. class ( nelder_mead ), intent ( inout ) :: this !! The [[nelder_mead]] object. class ( fcnnvar_helper ), intent ( in ) :: fcn !! The function to evaluate. real ( real64 ), intent ( inout ), dimension (:) :: y !! An array containing the function values at each vertex. real ( real64 ), intent ( inout ), dimension (:) :: pcent !! An array containing the centroid of vertex position information. integer ( int32 ), intent ( in ) :: ihi !! The index of the largest magnitude vertex. real ( real64 ), intent ( in ) :: fac !! A scaling factor. integer ( int32 ), intent ( inout ) :: neval !! The number of function evaluations. real ( real64 ), intent ( out ), dimension (:) :: work !! An N-element workspace array where N is the number of dimensions !! of the problem. real ( real64 ) :: ytry !! The new function estimate. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , ndim real ( real64 ) :: fac1 , fac2 ! Initialization ndim = size ( this % m_simplex , 1 ) ! Define a trial point fac1 = ( one - fac ) / ndim fac2 = fac1 - fac do i = 1 , ndim work ( i ) = pcent ( i ) * fac1 - this % m_simplex ( i , ihi ) * fac2 end do ! Evaluate the function at the trial point, and then replace if the ! trial provides an improvement ytry = fcn % fcn ( work ) neval = neval + 1 if ( ytry < y ( ihi )) then y ( ihi ) = ytry do i = 1 , ndim pcent ( i ) = pcent ( i ) + work ( i ) - this % m_simplex ( i , ihi ) this % m_simplex ( i , ihi ) = work ( i ) end do end if end function ! ------------------------------------------------------------------------------ pure function nm_get_simplex ( this ) result ( p ) !! Gets an N-by-(N+1) matrix containing the current simplex. class ( nelder_mead ), intent ( in ) :: this !! The [[nelder_mead]] object. real ( real64 ), allocatable , dimension (:,:) :: p !! The N-by-(N+1) matrix containing the simplex.  Each vertex of !! the simplex is stored as its own column of this matrix. integer ( int32 ) :: m , n if ( allocated ( this % m_simplex )) then m = size ( this % m_simplex , 1 ) n = size ( this % m_simplex , 2 ) allocate ( p ( m , n )) p = this % m_simplex end if end function ! -------------------- subroutine nm_set_simplex ( this , x ) !! Sets an N-by-(N+1) matrix as the current simplex.  Notice, if !! this matrix is different in size from the problem dimensionallity, !! the Nelder-Mead routine will replace it with an appropriately sized !! matrix. class ( nelder_mead ), intent ( inout ) :: this !! The [[nelder_mead]] object. real ( real64 ), dimension (:,:) :: x !! The simplex matrix.  Each column of the matrix must contain the !! coordinates of each vertex of the simplex. integer ( int32 ) :: m , n m = size ( x , 1 ) n = size ( x , 2 ) if ( allocated ( this % m_simplex )) then if ( size ( this % m_simplex , 1 ) /= m . or . & size ( this % m_simplex , 2 ) /= n ) then deallocate ( this % m_simplex ) allocate ( this % m_simplex ( m , n )) end if else allocate ( this % m_simplex ( m , n )) end if this % m_simplex = x end subroutine ! ------------------------------------------------------------------------------ pure function nm_get_size ( this ) result ( x ) !! Gets the size of the initial simplex that will be utilized by !! the Nelder-Mead algorithm in the event that the user does not supply !! a simplex geometry, or if the user supplies an invalid simplex !! geometry. class ( nelder_mead ), intent ( in ) :: this !! The [[nelder_mead]] object. real ( real64 ) :: x !! The size of the simplex (length of an edge). x = this % m_initSize end function ! -------------------- subroutine nm_set_size ( this , x ) !! Sets the size of the initial simplex that will be utilized by !! the Nelder-Mead algorithm in the event that the user does not supply !! a simplex geometry, or if the user supplies an invalid simplex !! geometry. class ( nelder_mead ), intent ( inout ) :: this !! The [[nelder_mead]] object. real ( real64 ), intent ( in ) :: x !! The size of the simplex (length of an edge). this % m_initSize = x end subroutine ! ****************************************************************************** ! LINE_SEARCH_OPTIMIZER ! ------------------------------------------------------------------------------ subroutine lso_get_line_search ( this , ls ) !! Gets the line search module. class ( line_search_optimizer ), intent ( in ) :: this !! The [[line_search_optimizer]] object. class ( line_search ), intent ( out ), allocatable :: ls !! The [[line_search]] object. if ( allocated ( this % m_lineSearch )) & allocate ( ls , source = this % m_lineSearch ) end subroutine ! ---------------------- subroutine lso_set_line_search ( this , ls ) !! Sets the line search module. class ( line_search_optimizer ), intent ( inout ) :: this !! The [[line_search_optimizer]] object. class ( line_search ), intent ( in ) :: ls !! The [[line_search]] object. if ( allocated ( this % m_lineSearch )) deallocate ( this % m_lineSearch ) allocate ( this % m_lineSearch , source = ls ) end subroutine ! ------------------------------------------------------------------------------ subroutine lso_set_default ( this ) !! Establishes a default line_search object for the line search !! module. class ( line_search_optimizer ), intent ( inout ) :: this !! The [[line_search_optimizer]] object. type ( line_search ) :: ls call this % set_line_search ( ls ) end subroutine ! ------------------------------------------------------------------------------ pure function lso_is_line_search_defined ( this ) result ( x ) !! Tests to see if a line search module is defined. class ( line_search_optimizer ), intent ( in ) :: this !! The [[line_search_optimizer]] object. logical :: x !! Returns true if a module is defined; else, false. x = allocated ( this % m_lineSearch ) end function ! ------------------------------------------------------------------------------ pure function lso_get_use_search ( this ) result ( x ) !! Gets a value determining if a line-search should be employed. class ( line_search_optimizer ), intent ( in ) :: this !! The [[line_search_optimizer]] object. logical :: x !! Returns true if a line search should be used; else, false. x = this % m_useLineSearch end function ! -------------------- subroutine lso_set_use_search ( this , x ) !! Sets a value determining if a line-search should be employed. class ( line_search_optimizer ), intent ( inout ) :: this !! The [[line_search_optimizer]] object. logical , intent ( in ) :: x !! Set to true if a line search should be used; else, false. this % m_useLineSearch = x end subroutine ! ------------------------------------------------------------------------------ pure function lso_get_var_tol ( this ) result ( x ) !! Gets the convergence on change in variable tolerance. class ( line_search_optimizer ), intent ( in ) :: this !! The [[line_search_optimizer]] object. real ( real64 ) :: x !! The tolerance value. x = this % m_xtol end function ! -------------------- subroutine lso_set_var_tol ( this , x ) !! Sets the convergence on change in variable tolerance. class ( line_search_optimizer ), intent ( inout ) :: this !! The [[line_search_optimizer]] object. real ( real64 ), intent ( in ) :: x !! The tolerance value. this % m_xtol = x end subroutine ! ****************************************************************************** ! BFGS ! ------------------------------------------------------------------------------ module subroutine bfgs_solve ( this , fcn , x , fout , ib , err ) !! Utilizes the Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm !! for finding a minimum value of the specified function. class ( bfgs ), intent ( inout ) :: this !! The [[bfgs]] object. class ( fcnnvar_helper ), intent ( in ) :: fcn !! The [[fcnnvar_helper]] object containing the equation to !! optimize. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, the initial guess at the optimal point.  On output, !! the updated optimal point estimate. real ( real64 ), intent ( out ), optional :: fout !! An optional output, that if provided, returns the value of the !! function at x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: negone = - 1.0d0 real ( real64 ), parameter :: factor = 1.0d2 real ( real64 ), parameter :: small = 1.0d-10 ! Local Variables logical :: xcnvrg , gcnvrg integer ( int32 ) :: i , n , maxeval , neval , ngrad , flag , iter real ( real64 ) :: xtol , gtol , fp , stpmax , fret , xtest , gtest , temp , ydx real ( real64 ), allocatable , dimension (:) :: g , dx , u , v , y , gold , xnew , bdx real ( real64 ), allocatable , dimension (:,:) :: b , r class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 256 ) :: errmsg type ( iteration_behavior ) :: lib class ( line_search ), allocatable :: ls ! Initialization n = fcn % get_variable_count () maxeval = this % get_max_fcn_evals () gtol = this % get_tolerance () xtol = this % get_var_tolerance () iter = 0 neval = 0 ngrad = 0 xcnvrg = . false . gcnvrg = . false . if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = 0 ib % gradient_count = ngrad ib % converge_on_fcn = . false . ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = gcnvrg end if if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( this % get_use_line_search ()) then if (. not . this % is_line_search_defined ()) & call this % set_default_line_search () call this % get_line_search ( ls ) end if ! Input Check if (. not . fcn % is_fcn_defined ()) then ! ERROR: No function is defined call errmgr % report_error ( \"bfgs_solve\" , & \"No function has been defined.\" , & NL_INVALID_OPERATION_ERROR ) return end if if ( size ( x ) /= n ) then write ( errmsg , 100 ) & \"It was expected to receive a coordinate vector of length \" , & n , \" , but a vector of length \" , size ( x ), \" was received.\" call errmgr % report_error ( \"bfgs_solve\" , trim ( errmsg ), & NL_INVALID_INPUT_ERROR ) return end if ! Local Memory Allocation allocate ( g ( n ), stat = flag ) if ( flag == 0 ) allocate ( dx ( n ), stat = flag ) if ( flag == 0 ) allocate ( u ( n ), stat = flag ) if ( flag == 0 ) allocate ( v ( n ), stat = flag ) if ( flag == 0 ) allocate ( y ( n ), stat = flag ) if ( flag == 0 ) allocate ( bdx ( n ), stat = flag ) if ( flag == 0 ) allocate ( gold ( n ), stat = flag ) if ( flag == 0 ) allocate ( xnew ( n ), stat = flag ) if ( flag == 0 ) allocate ( b ( n , n ), stat = flag ) if ( flag == 0 ) allocate ( r ( n , n ), stat = flag ) if ( flag /= 0 ) then ! ERROR: Memory Error call errmgr % report_error ( \"bfgs_solve\" , & \"Insufficient memory available.\" , NL_OUT_OF_MEMORY_ERROR ) return end if ! Process fp = fcn % fcn ( x ) call fcn % gradient ( x , g , fp ) neval = 1 ngrad = 1 ! Check for a \"zero\" gradient at the initial point gtest = norm2 ( g ) if ( gtest < gtol ) then gcnvrg = . true . end if ! Main Loop flag = 0 if (. not . gcnvrg ) then do ! Update the iteration counter iter = iter + 1 ! Define the initial direction, and a limit on the line search ! step if ( iter == 1 ) then dx = - g stpmax = factor * max ( norm2 ( x ), real ( n , real64 )) end if ! Perform the line search if ( this % get_use_line_search ()) then call limit_search_vector ( dx , stpmax ) call ls % search ( fcn , x , g , dx , xnew , fp , fret , lib , errmgr ) neval = neval + lib % fcn_count fp = fret else xnew = x + dx fp = fcn % fcn ( xnew ) neval = neval + 1 end if ! Update the gradient and line direction do i = 1 , n dx ( i ) = xnew ( i ) - x ( i ) x ( i ) = xnew ( i ) gold ( i ) = g ( i ) end do call fcn % gradient ( x , g , fp ) ngrad = ngrad + 1 ! Test for convergence on the change in X xtest = zero do i = 1 , n temp = abs ( dx ( i )) / max ( abs ( x ( i )), one ) xtest = max ( temp , xtest ) end do if ( xtest < xtol ) then xcnvrg = . true . exit end if ! Test for convergence on the gradient gtest = norm2 ( g ) if ( gtest < gtol ) then gcnvrg = . true . exit end if ! Perform the BFGS update y = g - gold ydx = dot_product ( y , dx ) ! Establish an initial approximation to the Hessian matrix if ( iter == 1 ) then temp = sqrt ( dot_product ( y , y ) / ydx ) call dlaset ( 'A' , n , n , zero , temp , r , n ) end if ! Compute: B = R**T * R call tri_mtx_mult (. true ., one , r , zero , b ) ! Compute bdx = B * dX (B is symmetric) call dsymv ( 'u' , n , one , b , n , dx , 1 , zero , bdx , 1 ) ! Perform the actual update if ( ydx > small ) then ! Compute the rank 1 update and downdate u = y / sqrt ( ydx ) v = bdx / sqrt ( dot_product ( dx , bdx )) call cholesky_rank1_update ( r , u ) call cholesky_rank1_downdate ( r , v ) end if ! Else just skip the update ! Compute the solution to: B * dx = -g = (R**T * R) * dx dx = - g call solve_cholesky (. true ., r , dx ) ! Print iteration status if ( this % get_print_status ()) then print * , \"\" print 101 , \"Iteration: \" , iter print 101 , \"Function Evaluations: \" , neval print 102 , \"Function Value: \" , fp print 102 , \"Change in Variable: \" , xtest print 102 , \"Gradient: \" , gtest end if ! Ensure we haven't made too many function evaluations if ( neval >= maxeval ) then flag = 1 exit end if end do end if ! Report out iteration statistics if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = 0 ib % gradient_count = ngrad ib % converge_on_fcn = . false . ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = gcnvrg end if ! Get the function value at the computed minimum if ( present ( fout )) fout = fp ! Check for convergence issues if ( flag /= 0 ) then write ( errmsg , 103 ) & \"The algorithm failed to converge.\" // new_line ( 'c' ) // & \"Function evaluations performed: \" , neval , new_line ( 'c' ) // & \"Function Value: \" , fp , new_line ( 'c' ) // & \"Change in Variable: \" , xtest , new_line ( 'c' ) // & \"Gradient: \" , gtest call errmgr % report_error ( \"bfgs_solve\" , trim ( errmsg ), & NL_CONVERGENCE_ERROR ) end if ! Formatting 100 format ( A , I0 , A , I0 , A ) 101 format ( A , I0 ) 102 format ( A , E10 . 3 ) 103 format ( A , I0 , A , E10 . 3 , A , E10 . 3 , A , E10 . 3 ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\nonlin_optimize.f90.html"},{"title":"nonlin_polynomials.f90 – NONLIN","text":"Contents Modules nonlin_polynomials Source Code nonlin_polynomials.f90 Source Code module nonlin_polynomials use iso_fortran_env use linalg , only : eigen , solve_least_squares use ferror , only : errors use nonlin_error_handling implicit none private public :: polynomial public :: assignment ( = ) public :: operator ( + ) public :: operator ( - ) public :: operator ( * ) ! ****************************************************************************** ! INTERFACES ! ------------------------------------------------------------------------------ interface assignment ( = ) !! Defines polynomial assignment. module procedure :: poly_equals module procedure :: poly_dbl_equals module procedure :: poly_equals_array end interface interface operator ( + ) !! Defines polynomial addition. module procedure :: poly_poly_add end interface interface operator ( - ) !! Defines polynomial subtraction. module procedure :: poly_poly_subtract end interface interface operator ( * ) !! Defines polynomial multiplication module procedure :: poly_poly_mult module procedure :: poly_dbl_mult module procedure :: dbl_poly_mult end interface ! ****************************************************************************** ! TYPES ! ------------------------------------------------------------------------------ type polynomial !! Defines a polynomial, and associated routines for performing !! polynomial operations. real ( real64 ), private , allocatable , dimension (:) :: m_coeffs !! An array that contains the polynomial coefficients in ascending !! order. contains generic , public :: initialize => init_poly , init_poly_coeffs procedure , public :: order => get_poly_order procedure , public :: fit => poly_fit procedure , public :: fit_thru_zero => poly_fit_thru_zero generic , public :: evaluate => evaluate_real , evaluate_complex procedure , public :: companion_mtx => poly_companion_mtx procedure , public :: roots => poly_roots procedure , public :: get => get_poly_coefficient procedure , public :: get_all => get_poly_coefficients procedure , public :: set => set_poly_coefficient procedure , private :: evaluate_real => poly_eval_double procedure , private :: evaluate_complex => poly_eval_complex procedure , private :: init_poly procedure , private :: init_poly_coeffs end type contains ! ****************************************************************************** ! POLYNOMIAL MEMBERS ! ------------------------------------------------------------------------------ subroutine init_poly ( this , order , err ) !! Initializes the polynomial instance. class ( polynomial ), intent ( inout ) :: this !! The [[polynomial]] object. integer ( int32 ), intent ( in ) :: order !! The order of the polynomial (must be >= 0). class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: n , istat class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = order + 1 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( order < 0 ) then ! ERROR: Negative order is not supported call errmgr % report_error ( \"init_polynomial\" , & \"A negative polynomial order is not supported.\" , & NL_INVALID_INPUT_ERROR ) return end if ! Process if ( allocated ( this % m_coeffs )) deallocate ( this % m_coeffs ) allocate ( this % m_coeffs ( n ), stat = istat ) if ( istat /= 0 ) then ! ERROR: Out of memory call errmgr % report_error ( \"init_polynomial\" , & \"Insufficient memory available.\" , NL_OUT_OF_MEMORY_ERROR ) return end if this % m_coeffs = zero end subroutine ! ------------------------------------------------------------------------------ subroutine init_poly_coeffs ( this , c , err ) !! Initializes the polynomial instance. class ( polynomial ), intent ( inout ) :: this !! The [[polynomial]] object. real ( real64 ), intent ( in ), dimension (:) :: c !! The array of polynomial coefficients. The coefficients are !! established as follows: c(1) + c(2) * x + c(3) * x**2 + ... !! c(n) * x**n-1. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Local Variables integer ( int32 ) :: i , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( c ) if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Initialize the polynomial call init_poly ( this , n - 1 , errmgr ) if ( errmgr % has_error_occurred ()) return ! Populate the polynomial coefficients do i = 1 , n call this % set ( i , c ( i )) end do end subroutine ! ------------------------------------------------------------------------------ pure function get_poly_order ( this ) result ( n ) !! Returns the order of the polynomial object. class ( polynomial ), intent ( in ) :: this !! The [[polynomial]] object. integer ( int32 ) :: n !! The order of the polynomial.  Returns -1 in the event no !! polynomial coefficients have been defined. if (. not . allocated ( this % m_coeffs )) then n = - 1 else n = size ( this % m_coeffs ) - 1 end if end function ! ------------------------------------------------------------------------------ subroutine poly_fit ( this , x , y , order , err ) !! Fits a polynomial of the specified order to the supplied data set. class ( polynomial ), intent ( inout ) :: this !! The [[polynomial]] object. real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the independent variable data !! points.  Notice, must be N > order. real ( real64 ), intent ( inout ), dimension (:) :: y !! On input, an N-element array containing the dependent variable !! data points.  On output, the contents are overwritten. integer ( int32 ), intent ( in ) :: order !! The order of the polynomial (must be >= 1). class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: j , n , ncols , flag real ( real64 ), pointer , dimension (:,:) :: a class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( x ) ncols = order + 1 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( y ) /= n ) then ! ERROR: Array size mismatch call errmgr % report_error ( \"polynomial_fit\" , \"Array size mismatch.\" , & NL_ARRAY_SIZE_ERROR ) return else if ( order >= n . or . order < 1 ) then ! ERROR: Requested order does not make sense call errmgr % report_error ( \"polynomial_fit\" , \"The requested \" // & \"polynomial order is not valid for this data set.\" , & NL_INVALID_INPUT_ERROR ) return end if ! Local Memory Allocation allocate ( a ( n , ncols ), stat = flag ) if ( flag /= 0 ) then ! ERROR: Out of memory call errmgr % report_error ( \"polynomial_fit\" , & \"Insufficient memory available.\" , NL_OUT_OF_MEMORY_ERROR ) return end if ! Ensure the polynomial object is initialized and sized appropriately if ( this % order () /= order ) then call this % initialize ( order , errmgr ) if ( errmgr % has_error_occurred ()) return end if ! Populate A do j = 1 , n a ( j , 1 ) = one a ( j , 2 ) = x ( j ) end do do j = 3 , ncols a (:, j ) = a (:, j - 1 ) * x end do ! Solve: A * coeffs = y call solve_least_squares ( a , y , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Extract the coefficients from the first order+1 elements of Y this % m_coeffs = y ( 1 : ncols ) end subroutine ! ------------------------------------------------------------------------------ subroutine poly_fit_thru_zero ( this , x , y , order , err ) !! Fits a polynomial of the specified order that passes through zero !! to the supplied data set. class ( polynomial ), intent ( inout ) :: this !! The [[polynomial]] object. real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the independent variable data !! points.  Notice, must be N > order. real ( real64 ), intent ( inout ), dimension (:) :: y !! On input, an N-element array containing the dependent !! variable data points.  On output, the contents are overwritten. integer ( int32 ), intent ( in ) :: order !! The order of the polynomial (must be >= 1). class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: j , n , ncols , flag real ( real64 ), pointer , dimension (:,:) :: a class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( x ) ncols = order if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if ( size ( y ) /= n ) then ! ERROR: Array size mismatch call errmgr % report_error ( \"polynomial_fit_thru_zero\" , & \"Array size mismatch.\" , NL_ARRAY_SIZE_ERROR ) return else if ( order >= n . or . order < 1 ) then ! ERROR: Requested order does not make sense call errmgr % report_error ( \"polynomial_fit_thru_zero\" , & \"The requested polynomial order is not valid for this \" // & \"data set.\" , NL_INVALID_INPUT_ERROR ) return end if ! Local Memory Allocation allocate ( a ( n , ncols ), stat = flag ) if ( flag /= 0 ) then ! ERROR: Out of memory call errmgr % report_error ( \"polynomial_fit_thru_zero\" , & \"Insufficient memory available.\" , NL_OUT_OF_MEMORY_ERROR ) return end if ! Ensure the polynomial object is initialized and sized appropriately if ( this % order () /= order ) then call this % initialize ( order , errmgr ) if ( errmgr % has_error_occurred ()) return end if ! Populate A a (:, 1 ) = x do j = 2 , ncols a (:, j ) = a (:, j - 1 ) * x end do ! Solve: A * coeffs = y call solve_least_squares ( a , y , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Extract the coefficients from the first order+1 elements of Y this % m_coeffs ( 1 ) = zero this % m_coeffs ( 2 : ncols + 1 ) = y ( 1 : ncols ) end subroutine ! ------------------------------------------------------------------------------ elemental function poly_eval_double ( this , x ) result ( y ) !! Evaluates a polynomial at the specified points. class ( polynomial ), intent ( in ) :: this !! The [[polynomial]] object. real ( real64 ), intent ( in ) :: x !! The value(s) at which to evaluate the polynomial. real ( real64 ) :: y !! The value(s) of the polynomial at x. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: j , order , n ! Initialization order = this % order () n = order + 1 if ( order == - 1 ) then y = zero return else if ( order == 0 ) then y = this % m_coeffs ( 1 ) return end if ! Process y = this % m_coeffs ( n ) * x + this % m_coeffs ( order ) do j = n - 2 , 1 , - 1 y = y * x + this % m_coeffs ( j ) end do end function ! ------------------------------------------------------------------------------ elemental function poly_eval_complex ( this , x ) result ( y ) !! Evaluates a polynomial at the specified points. class ( polynomial ), intent ( in ) :: this !! The [[polynomial]] object. complex ( real64 ), intent ( in ) :: x !! The value(s) at which to evaluate the polynomial. complex ( real64 ) :: y !! The value(s) of the polynomial at x. ! Parameters complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: j , order , n ! Initialization order = this % order () n = order + 1 if ( order == - 1 ) then y = zero return else if ( order == 0 ) then y = this % m_coeffs ( 1 ) return end if ! Process y = this % m_coeffs ( n ) * x + this % m_coeffs ( order ) do j = n - 2 , 1 , - 1 y = y * x + this % m_coeffs ( j ) end do end function ! ------------------------------------------------------------------------------ pure function poly_companion_mtx ( this ) result ( c ) !! Returns the companion matrix for the polynomial. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Companion_matrix) !! !! - [Wolfram MathWorld](http://mathworld.wolfram.com/CompanionMatrix.html) class ( polynomial ), intent ( in ) :: this !! The [[polynomial]] object. real ( real64 ), dimension ( this % order (), this % order ()) :: c !! The companion matrix. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , n ! Process n = this % order () if ( n == - 1 ) return c = zero do i = 1 , n c ( i , n ) = - this % m_coeffs ( i ) / this % m_coeffs ( n + 1 ) if ( i < n ) c ( i + 1 , i ) = one end do end function ! ------------------------------------------------------------------------------ function poly_roots ( this , err ) result ( z ) !! Computes all the roots of a polynomial by computing the eigenvalues !! of the polynomial companion matrix. class ( polynomial ), intent ( in ) :: this !! The [[polynomial]] object. complex ( real64 ), dimension ( this % order ()) :: z !! The roots of the polynomial. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Local Variables integer ( int32 ) :: n real ( real64 ), allocatable , dimension (:,:) :: c ! Initialization n = this % order () ! Quick Return if ( n == 0 ) return ! Compute the companion matrix c = this % companion_mtx () ! Compute the eigenvalues of the companion matrix.  The eigenvalues are ! the roots of the polynomial. call eigen ( c , z , err = err ) end function ! ------------------------------------------------------------------------------ function get_poly_coefficient ( this , ind , err ) result ( c ) !! Gets the requested polynomial coefficient by index.  The !! coefficient index is established as follows: c(1) + c(2) * x + !! c(3) * x**2 + ... c(n) * x**n-1. class ( polynomial ), intent ( in ) :: this !! The [[polynomial]] object. integer ( int32 ), intent ( in ) :: ind !! The polynomial coefficient index. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. real ( real64 ) :: c !! The requested coefficient. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization c = 0.0d0 if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Quick Return if ( this % order () == - 1 ) return ! Input Check if ( ind <= 0 . or . ind > this % order () + 1 ) then ! ERROR: Index out of range call errmgr % report_error ( \"get_polynomial_coefficient\" , & \"The specified index is outside the bounds of the \" // & \"coefficient array.\" , NL_INVALID_INPUT_ERROR ) return end if ! Get the coefficient c = this % m_coeffs ( ind ) end function ! ------------------------------------------------------------------------------ pure function get_poly_coefficients ( this ) result ( c ) !! Gets an array containing all the coefficients of the polynomial. !! The coefficient index is established as follows: c(1) + c(2) * x + !! c(3) * x**2 + ... c(n) * x**n-1. class ( polynomial ), intent ( in ) :: this !! The [[polynomial]] object. real ( real64 ), dimension ( this % order () + 1 ) :: c !! The array of coefficients. ! Process if ( this % order () == - 1 ) return c = this % m_coeffs end function ! ------------------------------------------------------------------------------ subroutine set_poly_coefficient ( this , ind , c , err ) !! Sets the requested polynomial coefficient by index.  The !! coefficient index is established as follows: c(1) + c(2) * x + !! c(3) * x**2 + ... c(n) * x**n-1. class ( polynomial ), intent ( inout ) :: this !! The [[polynomial]] object. integer ( int32 ), intent ( in ) :: ind !! The polynomial coefficient index. real ( real64 ), intent ( in ) :: c !! The polynomial coefficient. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Quick Return if ( this % order () == - 1 ) return ! Input Check if ( ind <= 0 . or . ind > this % order () + 1 ) then ! ERROR: Index out of range call errmgr % report_error ( \"set_polynomial_coefficient\" , & \"The specified index is outside the bounds of the \" // & \"coefficient array.\" , NL_INVALID_INPUT_ERROR ) return end if ! Process this % m_coeffs ( ind ) = c end subroutine ! ****************************************************************************** ! OPERATORS ! ------------------------------------------------------------------------------ subroutine poly_equals ( x , y ) !! Assigns the contents of one polynomial to another. class ( polynomial ), intent ( inout ) :: x !! The assignee. class ( polynomial ), intent ( in ) :: y !! The item to copy. ! Local Variables integer ( int32 ) :: i , ord ! Process ord = y % order () if ( x % order () /= ord ) call x % initialize ( ord ) do i = 1 , ord + 1 call x % set ( i , y % get ( i )) end do end subroutine ! ------------------------------------------------------------------------------ subroutine poly_dbl_equals ( x , y ) !! Assigns a number to each coefficient of the polynomial. class ( polynomial ), intent ( inout ) :: x !! The assignee. real ( real64 ), intent ( in ) :: y !! The value to assign. ! Local Variables integer ( int32 ) :: i , ord ! Process ord = x % order () do i = 1 , ord + 1 call x % set ( i , y ) end do end subroutine ! ------------------------------------------------------------------------------ subroutine poly_equals_array ( x , y ) !! Assigns the contents of an array as polynomial coefficients. class ( polynomial ), intent ( inout ) :: x !! The assignee. real ( real64 ), intent ( in ), dimension (:) :: y !! The coefficient array. call x % initialize ( y ) end subroutine ! ------------------------------------------------------------------------------ function poly_poly_add ( x , y ) result ( z ) !! Adds two polynomials. class ( polynomial ), intent ( in ) :: x !! The left-hand-side argument. class ( polynomial ), intent ( in ) :: y !! The right-hand-side argument. type ( polynomial ) :: z !! The resulting polynomial. ! Local Variables integer ( int32 ) :: i , max_ord , x_ord , y_ord ! Initialization x_ord = x % order () y_ord = y % order () max_ord = max ( x_ord , y_ord ) call z % initialize ( max_ord ) ! Quick Return if ( x_ord == - 1 . and . y_ord == - 1 ) return if ( x_ord == - 1 . and . y_ord /= - 1 ) then do i = 1 , max_ord + 1 call z % set ( i , y % get ( i )) end do return else if ( x_ord /= - 1 . and . y_ord == - 1 ) then do i = 1 , max_ord + 1 call z % set ( i , x % get ( i )) end do return end if ! Process if ( x_ord > y_ord ) then do i = 1 , y_ord + 1 call z % set ( i , x % get ( i ) + y % get ( i )) end do do i = y_ord + 2 , x_ord call z % set ( i , x % get ( i )) end do else if ( x_ord < y_ord ) then do i = 1 , x_ord + 1 call z % set ( i , x % get ( i ) + y % get ( i )) end do do i = x_ord + 2 , y_ord + 1 call z % set ( i , y % get ( i )) end do else do i = 1 , max_ord + 1 call z % set ( i , x % get ( i ) + y % get ( i )) end do end if end function ! ------------------------------------------------------------------------------ function poly_poly_subtract ( x , y ) result ( z ) !! Subtracts two polynomials. class ( polynomial ), intent ( in ) :: x !! The left-hand-side argument. class ( polynomial ), intent ( in ) :: y !! The right-hand-side argument. type ( polynomial ) :: z !! The resulting polynomial. ! Local Variables integer ( int32 ) :: i , max_ord , x_ord , y_ord ! Initialization x_ord = x % order () y_ord = y % order () max_ord = max ( x_ord , y_ord ) call z % initialize ( max_ord ) ! Quick Return if ( x_ord == - 1 . and . y_ord == - 1 ) return if ( x_ord == - 1 . and . y_ord /= - 1 ) then do i = 1 , max_ord + 1 call z % set ( i , y % get ( i )) end do return else if ( x_ord /= - 1 . and . y_ord == - 1 ) then do i = 1 , max_ord + 1 call z % set ( i , x % get ( i )) end do return end if ! Process if ( x_ord > y_ord ) then do i = 1 , y_ord + 1 call z % set ( i , x % get ( i ) - y % get ( i )) end do do i = y_ord + 2 , x_ord call z % set ( i , x % get ( i )) end do else if ( x_ord < y_ord ) then do i = 1 , x_ord + 1 call z % set ( i , x % get ( i ) - y % get ( i )) end do do i = x_ord + 2 , y_ord + 1 call z % set ( i , - y % get ( i )) end do else do i = 1 , max_ord + 1 call z % set ( i , x % get ( i ) - y % get ( i )) end do end if end function ! ------------------------------------------------------------------------------ function poly_poly_mult ( x , y ) result ( z ) !! Multiplies two polynomials. class ( polynomial ), intent ( in ) :: x !! The left-hand-side argument. class ( polynomial ), intent ( in ) :: y !! The right-hand-side argument. type ( polynomial ) :: z !! The resulting polynomial. ! Local Variables integer ( int32 ) :: i , j , m , n real ( real64 ) :: val ! Initialization n = x % order () + 1 m = y % order () + 1 call z % initialize ( x % order () + y % order ()) ! Sets z to all zeros ! Process do i = 1 , n do j = 1 , m val = z % get ( i + j - 1 ) + x % get ( i ) * y % get ( j ) call z % set ( i + j - 1 , val ) end do end do end function ! ------------------------------------------------------------------------------ function poly_dbl_mult ( x , y ) result ( z ) !! Multiplies a polynomial by a scalar value. class ( polynomial ), intent ( in ) :: x !! The left-hand-side argument. real ( real64 ), intent ( in ) :: y !! The right-hand-side argument. type ( polynomial ) :: z !! The resulting polynomial. ! Local Variables integer ( int32 ) :: i , ord ! Process ord = x % order () call z % initialize ( ord ) do i = 1 , ord + 1 call z % set ( i , x % get ( i ) * y ) end do end function ! ------------------------------------------------------------------------------ function dbl_poly_mult ( x , y ) result ( z ) !! Multiplies a polynomial by a scalar value. real ( real64 ), intent ( in ) :: x !! The left-hand-side argument. class ( polynomial ), intent ( in ) :: y !! The right-hand-side argument. type ( polynomial ) :: z !! The resulting polynomial. ! Local Variables integer ( int32 ) :: i , ord ! Process ord = y % order () call z % initialize ( ord ) do i = 1 , ord + 1 call z % set ( i , y % get ( i ) * x ) end do end function ! ------------------------------------------------------------------------------ ! Example Polynomial Code (Coefficients go from lowest order to highest) ! src: https://github.com/JuliaMath/Polynomials.jl ! ! function *{T,S}(p1::Poly{T}, p2::Poly{S}) !     if p1.var != p2.var !         error(\"Polynomials must have same variable\") !     end !     R = promote_type(T,S) !     n = length(p1)-1 !     m = length(p2)-1 !     a = zeros(R,m+n+1) !     for i = 0:n !         for j = 0:m !             a[i+j+1] += p1[i] * p2[j] !         end !     end !     Poly(a,p1.var) ! end ! ## older . operators, hack to avoid warning on v0.6 ! dot_operators = quote !     @compat Base.:.+{T<:Number}(c::T, p::Poly) = +(p, c) !     @compat Base.:.+{T<:Number}(p::Poly, c::T) = +(p, c) !     @compat Base.:.-{T<:Number}(p::Poly, c::T) = +(p, -c) !     @compat Base.:.-{T<:Number}(c::T, p::Poly) = +(p, -c) !     @compat Base.:.*{T<:Number,S}(c::T, p::Poly{S}) = Poly(c * p.a, p.var) !     @compat Base.:.*{T<:Number,S}(p::Poly{S}, c::T) = Poly(p.a * c, p.var) ! end ! VERSION < v\"0.6.0-dev\" && eval(dot_operators) ! # are any values NaN ! hasnan(p::Poly) = reduce(|, (@compat isnan.(p.a))) ! function divrem{T, S}(num::Poly{T}, den::Poly{S}) !     if num.var != den.var !         error(\"Polynomials must have same variable\") !     end !     m = length(den)-1 !     if m == 0 && den[0] == 0 !         throw(DivideError()) !     end !     R = typeof(one(T)/one(S)) !     n = length(num)-1 !     deg = n-m+1 !     if deg <= 0 !         return convert(Poly{R}, zero(num)), convert(Poly{R}, num) !     end !     aQ = zeros(R, deg) !     # aR = deepcopy(num.a) !     # @show num.a !     aR = R[ num.a[i] for i = 1:n+1 ] !     for i = n:-1:m !         quot = aR[i+1] / den[m] !         aQ[i-m+1] = quot !         for j = 0:m !             elem = den[j]*quot !             aR[i-(m-j)+1] -= elem !         end !     end !     pQ = Poly(aQ, num.var) !     pR = Poly(aR, num.var) !     return pQ, pR ! end ! div(num::Poly, den::Poly) = divrem(num, den)[1] ! rem(num::Poly, den::Poly) = divrem(num, den)[2] ! ==(p1::Poly, p2::Poly) = (p1.var == p2.var && p1.a == p2.a) ! ==(p1::Poly, n::Number) = (coeffs(p1) == [n]) ! ==(n::Number, p1::Poly) = (p1 == n) end module","tags":"","loc":"sourcefile\\nonlin_polynomials.f90.html"},{"title":"nonlin_single_var.f90 – NONLIN","text":"Contents Modules nonlin_single_var Source Code nonlin_single_var.f90 Source Code module nonlin_single_var use iso_fortran_env use nonlin_types use ferror implicit none private public :: fcn1var public :: fcn1var_helper public :: equation_solver_1var public :: nonlin_solver_1var interface function fcn1var ( x ) result ( f ) !! Describes a function of one variable. use , intrinsic :: iso_fortran_env , only : real64 real ( real64 ), intent ( in ) :: x !! The independent variable. real ( real64 ) :: f !! The value of the function at x. end function end interface type fcn1var_helper !! Defines a type capable of encapsulating an equation of one !! variable of the form: f(x) = 0. procedure ( fcn1var ), private , pointer , nopass :: m_fcn => null () !! A pointer to the target fcn1var routine. procedure ( fcn1var ), private , pointer , nopass :: m_diff => null () !! A pointer to a function capable of computing the derivative of !! m_fcn. contains procedure , public :: fcn => f1h_fcn procedure , public :: is_fcn_defined => f1h_is_fcn_defined procedure , public :: set_fcn => f1h_set_fcn procedure , public :: is_derivative_defined => f1h_is_diff_defined procedure , public :: diff => f1h_diff_fcn procedure , public :: set_diff => f1h_set_diff end type type , abstract :: equation_solver_1var !! A base class for various solvers of equations of one variable. integer ( int32 ), private :: m_maxEval = 100 !! The maximum number of function evaluations allowed per solve. real ( real64 ), private :: m_fcnTol = 1.0d-8 !! The convergence criteria on function value. real ( real64 ), private :: m_xtol = 1.0d-12 !! The convergence criteria on change in variable value. real ( real64 ), private :: m_difftol = 1.0d-12 !! The convergence criteria on the slope of the function !! (derivative). logical , private :: m_printStatus = . false . !! Set to true to print iteration status; else, false. contains procedure , public :: get_max_fcn_evals => es1_get_max_eval procedure , public :: set_max_fcn_evals => es1_set_max_eval procedure , public :: get_fcn_tolerance => es1_get_fcn_tol procedure , public :: set_fcn_tolerance => es1_set_fcn_tol procedure , public :: get_var_tolerance => es1_get_var_tol procedure , public :: set_var_tolerance => es1_set_var_tol procedure , public :: get_print_status => es1_get_print_status procedure , public :: set_print_status => es1_set_print_status procedure ( nonlin_solver_1var ), deferred , public , pass :: solve procedure , public :: get_diff_tolerance => es1_get_diff_tol procedure , public :: set_diff_tolerance => es1_set_diff_tol end type interface subroutine nonlin_solver_1var ( this , fcn , x , lim , f , ib , err ) !! Describes the interface of a solver for an equation of one !! variable. use , intrinsic :: iso_fortran_env , only : real64 use nonlin_types , only : iteration_behavior , value_pair use ferror , only : errors import equation_solver_1var import fcn1var_helper class ( equation_solver_1var ), intent ( inout ) :: this !! The [[equation_solver_1var]] object. class ( fcn1var_helper ), intent ( in ) :: fcn !! The fcn1var_helper object containing the equation to solve. real ( real64 ), intent ( inout ) :: x !! On input the initial guess at the solution.  On output the !! solution. type ( value_pair ), intent ( in ) :: lim !! A value_pair object defining the search limits. real ( real64 ), intent ( out ), optional :: f !! An optional parameter used to return the function residual !! as computed at x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the !! caller to obtain iteration performance information. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. end subroutine end interface contains ! ****************************************************************************** ! FCN1VAR_HELPER ! ------------------------------------------------------------------------------ function f1h_fcn ( this , x ) result ( f ) !! Executes the routine containing the function to evaluate. class ( fcn1var_helper ), intent ( in ) :: this !! The [[fcn1var_helper]] object. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which the function !! should be evaluated. real ( real64 ) :: f !! The value of the function. if ( associated ( this % m_fcn )) then f = this % m_fcn ( x ) end if end function ! ------------------------------------------------------------------------------ function f1h_is_fcn_defined ( this ) result ( x ) !! Tests if the pointer to the function containing the equation !! to solve has been assigned. class ( fcn1var_helper ), intent ( in ) :: this !! The [[fcn1var_helper]] object. logical :: x !! Returns true if the pointer has been assigned; else, false. x = associated ( this % m_fcn ) end function ! ------------------------------------------------------------------------------ subroutine f1h_set_fcn ( this , fcn ) !! Establishes a pointer to the routine containing the equations !! to solve. class ( fcn1var_helper ), intent ( inout ) :: this !! The [[fcn1var_helper]] object. procedure ( fcn1var ), intent ( in ), pointer :: fcn !! The function pointer. this % m_fcn => fcn end subroutine ! ------------------------------------------------------------------------------ function f1h_is_diff_defined ( this ) result ( x ) !! Tests if the pointer to the function containing the derivative of !! the function to solve is defined. class ( fcn1var_helper ), intent ( in ) :: this !! The [[fcn1var_helper]] object. logical :: x !! Returns true if the pointer has been assigned; else, false. x = associated ( this % m_diff ) end function ! ------------------------------------------------------------------------------ function f1h_diff_fcn ( this , x , f ) result ( df ) !! Computes the derivative of the function.  If a routine for computing !! the derivative is not defined, the derivative is estimated via !! finite differences. class ( fcn1var_helper ), intent ( in ) :: this !! The [[fcn1var_helper]] object. real ( real64 ), intent ( in ) :: x !! The value of the independent variable at which the derivative is !! to be computed. real ( real64 ), intent ( in ), optional :: f !! An optional input specifying the function value at x.  If !! supplied, and the derivative is being estimated numerically, the !! function will not be evaluated at x. real ( real64 ) :: df !! The value of the derivative. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables real ( real64 ) :: eps , epsmch , h , temp , f1 , f0 ! Initialization epsmch = epsilon ( epsmch ) eps = sqrt ( epsmch ) ! Process if ( this % is_derivative_defined ()) then ! Use the user-defined routine to compute the derivative df = this % m_diff ( x ) else ! Compute the derivative via a forward difference h = eps * abs ( x ) if ( h < epsmch ) h = eps temp = x + h f1 = this % fcn ( temp ) if ( present ( f )) then f0 = f else f0 = this % fcn ( x ) end if df = ( f1 - f0 ) / h end if end function ! ------------------------------------------------------------------------------ subroutine f1h_set_diff ( this , diff ) !! Establishes a pointer to the routine containing the derivative of the !! equations to solve. class ( fcn1var_helper ), intent ( inout ) :: this !! The [[fcn1var_helper]] object. procedure ( fcn1var ), pointer , intent ( in ) :: diff !! A pointer to the function for computing the first derivative. this % m_diff => diff end subroutine ! ****************************************************************************** ! EQUATION_SOLVER_1VAR ! ------------------------------------------------------------------------------ pure function es1_get_max_eval ( this ) result ( n ) !! Gets the maximum number of function evaluations allowed during !! a single solve. class ( equation_solver_1var ), intent ( in ) :: this !! The [[equation_solver_1var]] object. integer ( int32 ) :: n !! The maximum number of function evaluations. n = this % m_maxEval end function ! -------------------- subroutine es1_set_max_eval ( this , n ) !! Sets the maximum number of function evaluations allowed during !! a single solve. class ( equation_solver_1var ), intent ( inout ) :: this !! The [[equation_solver_1var]] object. integer ( int32 ), intent ( in ) :: n !! The maximum number of function evaluations. this % m_maxEval = n end subroutine ! ------------------------------------------------------------------------------ pure function es1_get_fcn_tol ( this ) result ( x ) !! Gets the convergence on function value tolerance. class ( equation_solver_1var ), intent ( in ) :: this !! The [[equation_solver_1var]] object. real ( real64 ) :: x !! The tolerance value. x = this % m_fcnTol end function ! -------------------- subroutine es1_set_fcn_tol ( this , x ) !! Sets the convergence on function value tolerance. class ( equation_solver_1var ), intent ( inout ) :: this !! The [[equation_solver_1var]] object. real ( real64 ), intent ( in ) :: x !! The tolerance value. this % m_fcnTol = x end subroutine ! ------------------------------------------------------------------------------ pure function es1_get_var_tol ( this ) result ( x ) !! Gets the convergence on change in variable tolerance. class ( equation_solver_1var ), intent ( in ) :: this !! The [[equation_solver_1var]] object. real ( real64 ) :: x !! The tolerance value. x = this % m_xtol end function ! -------------------- subroutine es1_set_var_tol ( this , x ) !! Sets the convergence on change in variable tolerance. class ( equation_solver_1var ), intent ( inout ) :: this !! The [[equation_solver_1var]] object. real ( real64 ), intent ( in ) :: x !! The tolerance value. this % m_xtol = x end subroutine ! ------------------------------------------------------------------------------ pure function es1_get_print_status ( this ) result ( x ) !! Gets a logical value determining if iteration status should be !! printed. class ( equation_solver_1var ), intent ( in ) :: this !! The [[equation_solver_1var]] object. logical :: x !! True if the iteration status should be printed; else, false. x = this % m_printStatus end function ! -------------------- subroutine es1_set_print_status ( this , x ) !! Sets a logical value determining if iteration status should be !! printed. class ( equation_solver_1var ), intent ( inout ) :: this !! The [[equation_solver_1var]] object. logical , intent ( in ) :: x !! True if the iteration status should be printed; else, false. this % m_printStatus = x end subroutine ! ------------------------------------------------------------------------------ pure function es1_get_diff_tol ( this ) result ( x ) !! Gets the convergence on slope of the function (derivative) !! tolerance. class ( equation_solver_1var ), intent ( in ) :: this !! The [[equation_solver_1var]] object. real ( real64 ) :: x !! The tolerance value. x = this % m_difftol end function ! -------------------- subroutine es1_set_diff_tol ( this , x ) !! Sets the convergence on slope of the function (derivative) !! tolerance. class ( equation_solver_1var ), intent ( inout ) :: this !! The [[equation_solver_1var]] object. real ( real64 ), intent ( in ) :: x !! The tolerance value. this % m_difftol = x end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\nonlin_single_var.f90.html"},{"title":"nonlin_solve.f90 – NONLIN","text":"Contents Modules nonlin_solve Source Code nonlin_solve.f90 Source Code module nonlin_solve use iso_fortran_env use nonlin_error_handling use nonlin_multi_eqn_mult_var use nonlin_single_var use nonlin_linesearch use nonlin_helper use nonlin_types use ferror use linalg , only : qr_factor , form_qr , qr_rank1_update , lu_factor , & rank1_update , mtx_mult , recip_mult_array , solve_triangular_system , & solve_lu implicit none private public :: line_search_solver public :: quasi_newton_solver public :: newton_solver public :: brent_solver public :: newton_1var_solver type , abstract , extends ( equation_solver ) :: line_search_solver !! A class describing nonlinear solvers that use a line search !! algorithm to improve convergence behavior. class ( line_search ), private , allocatable :: m_lineSearch !! The line search module. logical , private :: m_useLineSearch = . true . !! Set to true if a line search should be used regardless of the !! status of m_lineSearch contains procedure , public :: get_line_search => lss_get_line_search procedure , public :: set_line_search => lss_set_line_search procedure , public :: set_default_line_search => lss_set_default procedure , public :: is_line_search_defined => & lss_is_line_search_defined procedure , public :: get_use_line_search => lss_get_use_search procedure , public :: set_use_line_search => lss_set_use_search end type type , extends ( line_search_solver ) :: quasi_newton_solver !! Defines a quasi-Newton type solver based upon Broyden's method. integer ( int32 ), private :: m_jDelta = 5 !! The number of iterations that may pass between Jacobian !! calculation. contains procedure , public :: solve => qns_solve procedure , public :: get_jacobian_interval => qns_get_jac_interval procedure , public :: set_jacobian_interval => qns_set_jac_interval end type type , extends ( line_search_solver ) :: newton_solver !! Defines a Newton solver. contains procedure , public :: solve => ns_solve end type type , extends ( equation_solver_1var ) :: brent_solver !! Defines a solver based upon Brent's method for solving an equation !! of one variable without using derivatives. contains procedure , public :: solve => brent_solve end type type , extends ( equation_solver_1var ) :: newton_1var_solver !! Defines a solver based upon Newtons's method for solving an !! equation of one variable.  The algorithm uses a bisection method in !! conjunction with Newton's method in order to keep bounds upon the !! Newton iterations. contains procedure , public :: solve => newt1var_solve end type contains ! ****************************************************************************** ! LINE_SEARCH_SOLVER ! ------------------------------------------------------------------------------ subroutine lss_get_line_search ( this , ls ) !! Gets the line search module. class ( line_search_solver ), intent ( in ) :: this !! The [[line_search_solver]] object. class ( line_search ), intent ( out ), allocatable :: ls !! The [[line_search]] object. if ( allocated ( this % m_lineSearch )) & allocate ( ls , source = this % m_lineSearch ) end subroutine ! ---------------------- subroutine lss_set_line_search ( this , ls ) !! Sets the line search module. class ( line_search_solver ), intent ( inout ) :: this !! The [[line_search_solver]] object. class ( line_search ), intent ( in ) :: ls !! The [[line_search]] object. if ( allocated ( this % m_lineSearch )) deallocate ( this % m_lineSearch ) allocate ( this % m_lineSearch , source = ls ) end subroutine ! ------------------------------------------------------------------------------ subroutine lss_set_default ( this ) !! Establishes a default line_search object for the line search !! module. class ( line_search_solver ), intent ( inout ) :: this !! The [[line_search_solver]] object. type ( line_search ) :: ls call this % set_line_search ( ls ) end subroutine ! ------------------------------------------------------------------------------ pure function lss_is_line_search_defined ( this ) result ( x ) !! Tests to see if a line search module is defined. class ( line_search_solver ), intent ( in ) :: this !! The [[line_search_solver]] object. logical :: x !! Returns true if a module is defined; else, false. x = allocated ( this % m_lineSearch ) end function ! ------------------------------------------------------------------------------ pure function lss_get_use_search ( this ) result ( x ) !! Gets a value determining if a line-search should be employed. class ( line_search_solver ), intent ( in ) :: this !! The [[line_search_solver]] object. logical :: x !! Returns true if a line search should be used; else, false. x = this % m_useLineSearch end function ! -------------------- subroutine lss_set_use_search ( this , x ) !! Sets a value determining if a line-search should be employed. class ( line_search_solver ), intent ( inout ) :: this !! The [[line_search_solver]] object. logical , intent ( in ) :: x !! Set to true if a line search should be used; else, false. this % m_useLineSearch = x end subroutine ! ****************************************************************************** ! QUASI_NEWTON_SOLVER ! ------------------------------------------------------------------------------ subroutine qns_solve ( this , fcn , x , fvec , ib , err ) !! Applies the quasi-Newton's method developed by Broyden in !! conjunction with a backtracking type line search to solve N equations !! of N unknowns. !! !! See Also: !! !! - [Broyden's Paper](http://www.ams.org/journals/mcom/1965-19-092/S0025-5718-1965-0198670-6/S0025-5718-1965-0198670-6.pdf) !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Broyden%27s_method) !! !! - [Numerical Recipes](http://numerical.recipes/) class ( quasi_newton_solver ), intent ( inout ) :: this !! The [[quasi_newton_solver]] object. class ( vecfcn_helper ), intent ( in ) :: fcn !! The [[vecfcn_helper]] object containing the equations to solve. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, an N-element array containing an initial estimate to !! the solution.  On output, the updated solution estimate.  N is !! the number of variables. real ( real64 ), intent ( out ), dimension (:) :: fvec !! An N-element array that, on output, will contain the values of !! each equation as evaluated at the variable values given in x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: factor = 1.0d2 ! Local Variables logical :: restart , xcnvrg , fcnvrg , gcnvrg , check integer ( int32 ) :: i , neqn , nvar , flag , lw1 , lw2 , lw3 , neval , iter , & maxeval , jcount , njac real ( real64 ), allocatable , dimension (:) :: work , tau , dx , df , fvold , & xold , s real ( real64 ), allocatable , dimension (:,:) :: q , r , b real ( real64 ) :: test , f , fold , temp , ftol , xtol , gtol , & stpmax , x2 , xnorm , fnorm type ( iteration_behavior ) :: lib class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 256 ) :: errmsg class ( line_search ), allocatable :: ls ! Initialization restart = . true . xcnvrg = . false . fcnvrg = . false . gcnvrg = . false . neqn = fcn % get_equation_count () nvar = fcn % get_variable_count () neval = 0 iter = 0 njac = 0 ftol = this % get_fcn_tolerance () xtol = this % get_var_tolerance () gtol = this % get_gradient_tolerance () maxeval = this % get_max_fcn_evals () if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = njac ib % gradient_count = 0 ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = gcnvrg end if if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( this % get_use_line_search ()) then if (. not . this % is_line_search_defined ()) & call this % set_default_line_search () call this % get_line_search ( ls ) end if ! Input Check if (. not . fcn % is_fcn_defined ()) then ! ERROR: No function is defined call errmgr % report_error ( \"qns_solve\" , & \"No function has been defined.\" , & NL_INVALID_OPERATION_ERROR ) return end if if ( nvar /= neqn ) then ! ERROR: # of equations doesn't match # of variables write ( errmsg , 100 ) \"The number of equations (\" , neqn , & \") does not match the number of unknowns (\" , nvar , \").\" call errmgr % report_error ( \"qns_solve\" , trim ( errmsg ), & NL_INVALID_INPUT_ERROR ) return end if flag = 0 if ( size ( x ) /= nvar ) then flag = 3 else if ( size ( fvec ) /= neqn ) then flag = 4 end if if ( flag /= 0 ) then ! One of the input arrays is not sized correctly write ( errmsg , 101 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"qns_solve\" , trim ( errmsg ), & NL_ARRAY_SIZE_ERROR ) return end if ! Local Memory Allocation allocate ( q ( neqn , neqn ), stat = flag ) if ( flag == 0 ) allocate ( r ( neqn , nvar ), stat = flag ) if ( flag == 0 ) allocate ( tau ( min ( neqn , nvar )), stat = flag ) if ( flag == 0 ) allocate ( b ( neqn , nvar ), stat = flag ) if ( flag == 0 ) allocate ( df ( neqn ), stat = flag ) if ( flag == 0 ) allocate ( fvold ( neqn ), stat = flag ) if ( flag == 0 ) allocate ( xold ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( dx ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( s ( neqn ), stat = flag ) if ( flag /= 0 ) then ! ERROR: Out of memory call errmgr % report_error ( \"qns_solve\" , & \"Insufficient memory available.\" , NL_OUT_OF_MEMORY_ERROR ) return end if call qr_factor ( r , tau , work , lw1 ) call form_qr ( r , tau , q , work , lw2 ) call fcn % jacobian ( x , b , fv = fvec , olwork = lw3 ) allocate ( work ( max ( lw1 , lw2 , lw3 )), stat = flag ) if ( flag /= 0 ) then ! ERROR: Out of memory call errmgr % report_error ( \"qns_solve\" , & \"Insufficient memory available.\" , NL_OUT_OF_MEMORY_ERROR ) return end if ! Test to see if the initial guess is a root call fcn % fcn ( x , fvec ) f = half * dot_product ( fvec , fvec ) neval = neval + 1 test = zero do i = 1 , neqn test = max ( abs ( fvec ( i )), test ) end do if ( test < ftol ) then fcnvrg = . true . end if ! Process flag = 0 ! Used to check for convergence errors if (. not . fcnvrg ) then ! Determine the maximum line search step stpmax = factor * max ( norm2 ( x ), real ( nvar , real64 )) ! Main Iteration Loop do ! Update the iteration counter iter = iter + 1 ! Compute or update the Jacobian if ( restart ) then ! Compute the Jacobian call fcn % jacobian ( x , b , fvec , work ) njac = njac + 1 ! Compute the QR factorization, and form Q & R r = b ! Copy the Jacobian - we'll need it later call qr_factor ( r , tau , work ) call form_qr ( r , tau , q , work ) ! Reset the Jacobian iteration counter jcount = 0 else ! Apply the rank 1 update to Q and R df = fvec - fvold dx = x - xold x2 = dot_product ( dx , dx ) ! Compute S = ALPHA * (DF - B * DX) s = ( df - matmul ( b , dx )) call recip_mult_array ( x2 , s ) ! Compute the new Q and R matrices for the rank1 update: ! B' = B + ALPHA * S * DX**T call rank1_update ( one , s , dx , b ) call qr_rank1_update ( q , r , s , dx , work ) ! S & DX overwritten ! Increment the counter tracking how many iterations have ! passed since the last Jacobian recalculation jcount = jcount + 1 end if ! Compute GRAD = B**T * F, store in DX call mtx_mult (. true ., one , b , fvec , zero , dx ) ! Store FVEC and X xold = x fvold = fvec fold = f ! Solve the linear system: B * DX = -F for DX noting that ! B = Q * R.  As such, form -Q**T * F, and store in DF call mtx_mult (. true ., - one , q , fvec , zero , df ) ! Now we have R * DX = -Q**T * F, and since R is upper ! triangular, the solution is readily computed.  The solution ! will be stored in the first NVAR elements of DF call solve_triangular_system (. true ., . false ., . true ., r , & df ( 1 : nvar )) ! Ensure the new solution estimate is heading in a sensible ! direction.  If not, it is likely time to update the Jacobian temp = dot_product ( dx , df ( 1 : nvar )) if ( temp >= zero ) then restart = . true . if ( this % get_print_status ()) then call print_status ( iter , neval , njac , xnorm , fnorm ) end if cycle end if ! Apply the line search if needed if ( this % get_use_line_search ()) then ! Define the step length for the line search temp = dot_product ( df ( 1 : nvar ), df ( 1 : nvar )) if ( temp > stpmax ) df ( 1 : nvar ) = df ( 1 : nvar ) * ( stpmax / temp ) ! Apply the line search call limit_search_vector ( df ( 1 : nvar ), stpmax ) call ls % search ( fcn , xold , dx , df ( 1 : nvar ), x , fvec , fold , & f , lib , errmgr ) neval = neval + lib % fcn_count else ! No line search - just update the solution estimate x = x + df ( 1 : nvar ) call fcn % fcn ( x , fvec ) f = half * dot_product ( fvec , fvec ) neval = neval + 1 end if ! Test for convergence if ( lib % converge_on_zero_diff . and . & this % get_use_line_search ()) then call test_convergence ( x , xold , fvec , dx , . true ., xtol , & ftol , gtol , check , xcnvrg , fcnvrg , gcnvrg , xnorm , fnorm ) else call test_convergence ( x , xold , fvec , dx , . false ., xtol , & ftol , gtol , check , xcnvrg , fcnvrg , gcnvrg , xnorm , fnorm ) end if if (. not . check ) then ! The solution did not converge, figure out why if ( gcnvrg ) then ! The slope of the gradient is sufficiently close to ! zero to cause issue. if ( restart ) then ! We've already tried recalculating a new Jacobian, ! issue a warning write ( errmsg , 102 ) & \"It appears the solution has settled to \" // & \"a point where the slope of the gradient \" // & \"is effectively zero.  \" // new_line ( 'c' ) // & \"Function evaluations performed: \" , neval , & \".\" // new_line ( 'c' ) // & \"Change in Variable: \" , xnorm , & new_line ( 'c' ) // \"Residual: \" , fnorm call errmgr % report_warning ( \"nqs_solve\" , & trim ( errmsg ), NL_SPURIOUS_CONVERGENCE_ERROR ) exit else ! Try computing a new Jacobian restart = . true . end if else ! We have not converged, but we're not stuck with a ! zero slope gradient vector either.  Go ahead and ! continue the iteration process without recomputing ! the Jacobian - unless the user dictates a ! recaclulation. if ( jcount >= this % m_jDelta ) then restart = . true . else restart = . false . end if end if else ! The solution has converged.  It's OK to exit exit end if ! Print status if ( this % get_print_status ()) then call print_status ( iter , neval , njac , xnorm , fnorm ) end if ! Ensure we haven't made too many function evaluations if ( neval >= maxeval ) then flag = 1 exit end if end do end if ! Report out iteration statistics if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = njac ib % gradient_count = 0 ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = gcnvrg end if ! Check for convergence issues if ( flag /= 0 ) then write ( errmsg , 102 ) \"The algorithm failed to \" // & \"converge.  Function evaluations performed: \" , neval , & \".\" // new_line ( 'c' ) // \"Change in Variable: \" , xnorm , & new_line ( 'c' ) // \"Residual: \" , fnorm call errmgr % report_error ( \"qns_solve\" , trim ( errmsg ), & NL_CONVERGENCE_ERROR ) end if ! Format 100 format ( A , I0 , A , I0 , A ) 101 format ( A , I0 , A ) 102 format ( A , I0 , A , E10 . 3 , A , E10 . 3 ) end subroutine ! ------------------------------------------------------------------------------ pure function qns_get_jac_interval ( this ) result ( n ) !! Gets the number of iterations that may pass before forcing a !! recalculation of the Jacobian matrix. class ( quasi_newton_solver ), intent ( in ) :: this !! The [[quasi_newton_solver]] object. integer ( int32 ) :: n !! The number of iterations. n = this % m_jDelta end function ! -------------------- subroutine qns_set_jac_interval ( this , n ) !! Sets the number of iterations that may pass before forcing a !! recalculation of the Jacobian matrix. class ( quasi_newton_solver ), intent ( inout ) :: this !! The [[quasi_newton_solver]] object. integer ( int32 ), intent ( in ) :: n !! The number of iterations. this % m_jDelta = n end subroutine ! ****************************************************************************** ! NEWTON_SOLVER ! ------------------------------------------------------------------------------ subroutine ns_solve ( this , fcn , x , fvec , ib , err ) !! Applies Newton's method in conjunction with a backtracking type !! line search to solve N equations of N unknowns. class ( newton_solver ), intent ( inout ) :: this !! The [[newton_solver]] object. class ( vecfcn_helper ), intent ( in ) :: fcn !! The [[vecfcn_helper]] object containing the equations to solve. real ( real64 ), intent ( inout ), dimension (:) :: x !! On input, an N-element array containing an initial estimate to !! the solution.  On output, the updated solution estimate.  N is !! the number of variables. real ( real64 ), intent ( out ), dimension (:) :: fvec !! An N-element array that, on output, will contain the values of !! each equation as evaluated at the variable values given in x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error-handling object. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: mintol = 1.0d-12 real ( real64 ), parameter :: factor = 1.0d2 ! Local Variables logical :: check , xcnvrg , fcnvrg , gcnvrg integer ( int32 ) :: i , neqn , nvar , lwork , flag , neval , iter , maxeval , njac integer ( int32 ), allocatable , dimension (:) :: ipvt real ( real64 ), allocatable , dimension (:) :: dir , grad , xold , work real ( real64 ), allocatable , dimension (:,:) :: jac real ( real64 ) :: ftol , xtol , gtol , f , fold , stpmax , xnorm , fnorm , temp , test type ( iteration_behavior ) :: lib class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 256 ) :: errmsg class ( line_search ), allocatable :: ls ! Initialization xcnvrg = . false . fcnvrg = . false . gcnvrg = . false . neqn = fcn % get_equation_count () nvar = fcn % get_variable_count () neval = 0 iter = 0 njac = 0 ftol = this % get_fcn_tolerance () xtol = this % get_var_tolerance () gtol = this % get_gradient_tolerance () maxeval = this % get_max_fcn_evals () if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = njac ib % gradient_count = 0 ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = gcnvrg end if if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( this % get_use_line_search ()) then if (. not . this % is_line_search_defined ()) & call this % set_default_line_search () call this % get_line_search ( ls ) end if ! Input Checking if (. not . fcn % is_fcn_defined ()) then ! ERROR: No function is defined call errmgr % report_error ( \"ns_solve\" , & \"No function has been defined.\" , & NL_INVALID_OPERATION_ERROR ) return end if if ( nvar /= neqn ) then ! ERROR: # of equations doesn't match # of variables write ( errmsg , 100 ) \"The number of equations (\" , neqn , & \") does not match the number of unknowns (\" , nvar , \").\" call errmgr % report_error ( \"ns_solve\" , trim ( errmsg ), & NL_INVALID_INPUT_ERROR ) return end if flag = 0 if ( size ( x ) /= nvar ) then flag = 3 else if ( size ( fvec ) /= neqn ) then flag = 4 end if if ( flag /= 0 ) then ! One of the input arrays is not sized correctly write ( errmsg , 101 ) \"Input number \" , flag , & \" is not sized correctly.\" call errmgr % report_error ( \"ns_solve\" , trim ( errmsg ), & NL_ARRAY_SIZE_ERROR ) return end if ! Local Memory Allocation allocate ( ipvt ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( dir ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( grad ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( xold ( nvar ), stat = flag ) if ( flag == 0 ) allocate ( jac ( nvar , neqn ), stat = flag ) if ( flag == 0 ) then call fcn % jacobian ( x , jac , fv = fvec , olwork = lwork ) allocate ( work ( lwork ), stat = flag ) end if if ( flag /= 0 ) then ! ERROR: Out of memory call errmgr % report_error ( \"ns_solve\" , & \"Insufficient memory available.\" , NL_OUT_OF_MEMORY_ERROR ) return end if ! Test to see if the initial guess is a root call fcn % fcn ( x , fvec ) f = half * dot_product ( fvec , fvec ) neval = neval + 1 test = zero do i = 1 , neqn test = max ( abs ( fvec ( i )), test ) end do if ( test < ftol ) then fcnvrg = . true . end if ! Process flag = 0 ! Used to check for convergence errors if (. not . fcnvrg ) then ! Compute the maximum step size for the line search process stpmax = factor * max ( norm2 ( x ), real ( nvar , real64 )) ! Main Iteration Loop do ! Increment the iteration counter iter = iter + 1 ! Compute the Jacobian call fcn % jacobian ( x , jac , fvec , work ) njac = njac + 1 ! Compute the gradient do i = 1 , nvar grad ( i ) = dot_product ( jac (:, i ), fvec ) end do ! Compute the LU factorization of the Jacobian call lu_factor ( jac , ipvt , errmgr ) if ( errmgr % has_warning_occurred ()) then ! The Jacobian is singular - warning was issued already, so ! simply exit the routine.  Do not return as a return at ! this point would not allow for proper updating of the ! iteration tracking parameters exit end if ! Store previous iteration values xold = x fold = f ! Define the right-hand-side for the linear system dir = - fvec ! Solve the linear system of equations call solve_lu ( jac , ipvt , dir ) ! Apply the line search if needed if ( this % get_use_line_search ()) then ! Define the step length for the line search temp = dot_product ( dir , dir ) if ( temp > stpmax ) dir = dir * ( stpmax / temp ) ! Apply the line search call limit_search_vector ( dir , stpmax ) call ls % search ( fcn , xold , grad , dir , x , fvec , & fold , f , lib , errmgr ) neval = neval + lib % fcn_count else ! No line search - just update the solution estimate x = x + dir call fcn % fcn ( x , fvec ) f = half * dot_product ( fvec , fvec ) neval = neval + 1 end if ! Check for convergence call test_convergence ( x , xold , fvec , grad , . true ., xtol , & ftol , gtol , check , xcnvrg , fcnvrg , gcnvrg , xnorm , fnorm ) if ( check ) then ! The solution has converged exit else if ( gcnvrg ) then ! The solution appears to have settled at a point where ! the gradient has a zero slope write ( errmsg , 102 ) & \"It appears the solution has settled to \" // & \"a point where the slope of the gradient \" // & \"is effectively zero.  \" // new_line ( 'c' ) // & \"Function evaluations performed: \" , neval , & \".\" // new_line ( 'c' ) // & \"Change in Variable: \" , xnorm , & new_line ( 'c' ) // \"Residual: \" , fnorm call errmgr % report_warning ( \"ns_solve\" , trim ( errmsg ), & NL_SPURIOUS_CONVERGENCE_ERROR ) end if ! Print status if ( this % get_print_status ()) then call print_status ( iter , neval , njac , xnorm , fnorm ) end if ! Ensure we haven't made too many function evaluations if ( neval >= maxeval ) then flag = 1 exit end if end do end if ! Report out iteration statistics if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = njac ib % gradient_count = 0 ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = gcnvrg end if ! Check for convergence issues if ( flag /= 0 ) then write ( errmsg , 102 ) \"The algorithm failed to \" // & \"converge.  Function evaluations performed: \" , neval , & \".\" // new_line ( 'c' ) // \"Change in Variable: \" , xnorm , & new_line ( 'c' ) // \"Residual: \" , fnorm call errmgr % report_error ( \"ns_solve\" , trim ( errmsg ), & NL_CONVERGENCE_ERROR ) end if ! Formatting 100 format ( A , I0 , A , I0 , A ) 101 format ( A , I0 , A ) 102 format ( A , I0 , A , E10 . 3 , A , E10 . 3 ) end subroutine ! ****************************************************************************** ! BRENT_SOLVER ! ------------------------------------------------------------------------------ subroutine brent_solve ( this , fcn , x , lim , f , ib , err ) !! Solves an equation of one variable using Brent's method. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Brent%27s_method) !! !! - [Numerical Recipes](http://numerical.recipes/) !! !! - R.P. Brent, \"Algorithms for Minimization without Derivatives,\" !!      Dover Publications, January 2002. ISBN 0-486-41998-3. !!      Further information available !!      [here](https://maths-people.anu.edu.au/~brent/pub/pub011.html). class ( brent_solver ), intent ( inout ) :: this !! The [[brent_solver]] object. class ( fcn1var_helper ), intent ( in ) :: fcn !! The [[fcn1var_helper]] object containing the equation to solve. real ( real64 ), intent ( inout ) :: x !! A parameter used to return the solution.  Notice, any input !! value will be ignored as this routine relies upon the search !! limits in lim to provide a starting point. type ( value_pair ), intent ( in ) :: lim !! A [[value_pair]] object defining the search limits. real ( real64 ), intent ( out ), optional :: f !! An optional parameter used to return the function residual as !! computed at x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 real ( real64 ), parameter :: three = 3.0d0 ! Local Variables logical :: fcnvrg , xcnvrg integer ( int32 ) :: neval , maxeval , flag , iter real ( real64 ) :: ftol , xtol , a , b , c , fa , fb , fc , p , q , r , s , xm , e , d , & mn1 , mn2 , eps , tol1 , temp class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 256 ) :: errmsg ! Initialization fcnvrg = . false . xcnvrg = . false . x = zero a = min ( lim % x1 , lim % x2 ) b = max ( lim % x1 , lim % x2 ) neval = 0 iter = 0 eps = epsilon ( eps ) ftol = this % get_fcn_tolerance () xtol = this % get_var_tolerance () maxeval = this % get_max_fcn_evals () if ( present ( f )) f = zero if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = 0 ib % gradient_count = 0 ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = . false . end if if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check if (. not . fcn % is_fcn_defined ()) then ! ERROR: No function is defined call errmgr % report_error ( \"brent_solve\" , & \"No function has been defined.\" , & NL_INVALID_OPERATION_ERROR ) return end if if ( abs ( a - b ) < eps ) then ! ERROR: Search limits are too tight write ( errmsg , 100 ) \"Search limits have no \" // & \"appreciable difference between them.  Lower Limit: \" , a , & \", Upper Limit: \" , b call errmgr % report_error ( \"brent_solve\" , trim ( errmsg ), & NL_INVALID_OPERATION_ERROR ) return end if ! Process flag = 0 fa = fcn % fcn ( a ) fb = fcn % fcn ( b ) neval = 2 fc = fb do ! Increment the iteration counter iter = iter + 1 ! Adjust the bounding interval if (( fb > zero . and . fc >= zero ) . or . & ( fb < zero . and . fc < zero )) then c = a fc = fa d = b - a e = d end if if ( abs ( fc ) < abs ( fb )) then a = b b = c c = a fa = fb fb = fc fc = fa end if ! Convergence Check tol1 = two * eps * abs ( b ) + half * xtol xm = half * ( c - b ) if ( abs ( fb ) < ftol ) then x = b fcnvrg = . true . exit end if if ( abs ( xm ) <= tol1 ) then x = b xcnvrg = . true . exit end if ! Actual Method if ( abs ( e ) >= tol1 . and . abs ( fa ) > abs ( fb )) then ! Attempt the inverse quadratic interpolation to determine ! the root s = fb / fa if ( abs ( a - c ) < eps ) then ! a == c p = two * xm * s q = one - s else q = fa / fc r = fb / fc p = s * ( two * xm * q * ( q - r ) - ( b - a ) * ( r - one )) q = ( q - one ) * ( r - one ) * ( s - one ) end if ! Ensure we're within bounds if ( p > zero ) q = - q p = abs ( p ) mn1 = three * xm * q - abs ( tol1 * q ) mn2 = abs ( e * q ) if ( mn1 < mn2 ) then temp = mn1 else temp = mn2 end if if ( two * p < temp ) then ! Accept the interpolation e = d d = p / q else ! The interpolation failed, use bisection d = xm e = d end if else ! The bounds are decreasing too slowly, use bisection d = xm e = d end if ! Move the last best guess to the lower limit parameter (A) a = b fa = fb if ( abs ( d ) > tol1 ) then b = b + d else b = b + sign ( tol1 , xm ) end if fb = fcn % fcn ( b ) neval = neval + 1 ! Print iteration status if ( this % get_print_status ()) then call print_status ( iter , neval , 0 , xm , fb ) end if ! Ensure we haven't made too many function evaluations if ( neval >= maxeval ) then flag = 1 exit end if end do ! Report out iteration statistics and other optional outputs if ( present ( f )) f = fb if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = 0 ib % gradient_count = 0 ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = . false . end if ! Check for convergence issues if ( flag /= 0 ) then write ( errmsg , 101 ) \"The algorithm failed to \" // & \"converge.  Function evaluations performed: \" , neval , & \".\" // new_line ( 'c' ) // \"Change in Variable: \" , xm , & new_line ( 'c' ) // \"Residual: \" , fb call errmgr % report_error ( \"brent_solve\" , trim ( errmsg ), & NL_CONVERGENCE_ERROR ) end if ! Formatting 100 format ( A , E10 . 3 , A , E10 . 3 ) 101 format ( A , I0 , A , E10 . 3 , A , E10 . 3 ) end subroutine ! ****************************************************************************** ! NEWTON_1VAR_SOLVER ! ------------------------------------------------------------------------------ subroutine newt1var_solve ( this , fcn , x , lim , f , ib , err ) !! Solves an equation of one variable using Newton's method. class ( newton_1var_solver ), intent ( inout ) :: this !! The [[newton_1var_solver]] object. class ( fcn1var_helper ), intent ( in ) :: fcn !! The [[fcn1var_helper]] object containing the equation to solve. real ( real64 ), intent ( inout ) :: x !! A parameter used to return the solution.  Notice, any input !! value will be ignored as this routine relies upon the search !! limits in lim to provide a starting point. type ( value_pair ), intent ( in ) :: lim !! A value_pair object defining the search limits. real ( real64 ), intent ( out ), optional :: f !! An optional parameter used to return the function residual as !! computed at x. type ( iteration_behavior ), optional :: ib !! An optional output, that if provided, allows the caller to !! obtain iteration performance statistics. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: p5 = 0.5d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables logical :: fcnvrg , xcnvrg , dcnvrg integer ( int32 ) :: neval , ndiff , maxeval , flag , iter real ( real64 ) :: ftol , xtol , dtol , xh , xl , fh , fl , x1 , x2 , eps , dxold , & dx , df , temp , ff class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 256 ) :: errmsg ! Initialization fcnvrg = . false . xcnvrg = . false . dcnvrg = . false . neval = 0 ndiff = 0 iter = 0 ftol = this % get_fcn_tolerance () xtol = this % get_var_tolerance () dtol = this % get_diff_tolerance () maxeval = this % get_max_fcn_evals () if ( present ( f )) f = zero if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = ndiff ib % gradient_count = 0 ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = dcnvrg end if if ( present ( err )) then errmgr => err else errmgr => deferr end if x1 = min ( lim % x1 , lim % x2 ) x2 = max ( lim % x1 , lim % x2 ) eps = epsilon ( eps ) ! Input Check if (. not . fcn % is_fcn_defined ()) then ! ERROR: No function is defined call errmgr % report_error ( \"brent_solve\" , & \"No function has been defined.\" , & NL_INVALID_OPERATION_ERROR ) return end if if ( abs ( x1 - x2 ) < eps ) then ! ERROR: Search limits are too tight write ( errmsg , 100 ) \"Search limits have no \" // & \"appreciable difference between them.  Lower Limit: \" , x1 , & \", Upper Limit: \" , x2 call errmgr % report_error ( \"brent_solve\" , trim ( errmsg ), & NL_INVALID_OPERATION_ERROR ) return end if ! See if the root is one of the end points flag = 0 fl = fcn % fcn ( x1 ) fh = fcn % fcn ( x2 ) neval = 2 if ( abs ( fl ) < ftol ) then x = x1 if ( present ( f )) f = fl if ( present ( ib )) then ib % converge_on_fcn = . true . ib % fcn_count = 2 end if return end if if ( abs ( fh ) < ftol ) then x = x2 if ( present ( f )) f = fh if ( present ( ib )) then ib % converge_on_fcn = . true . ib % fcn_count = 2 end if return end if ! Process if ( fl < zero ) then xl = x1 xh = x2 else xl = x2 xh = x1 end if x = p5 * ( x1 + x2 ) dxold = abs ( x2 - x1 ) dx = dxold ff = fcn % fcn ( x ) df = fcn % diff ( x , ff ) neval = neval + 1 ndiff = ndiff + 1 do ! Increment the iteration counter iter = iter + 1 ! Bisect if the Newton step went out of range, or if the rate ! of change was too slow if (((( x - xh ) * df - ff ) * (( x - xl ) * df - ff ) > zero ) . or . & ( abs ( two * ff ) > abs ( dxold * df ))) & then ! Bisection dxold = dx dx = p5 * ( xh - xl ) x = xl + dx if ( abs ( xl - x ) < xtol ) then ! Convergence as the change in root is within tolerance xcnvrg = . true . exit end if else ! Newton's Method dxold = dx dx = ff / df temp = x x = x - dx if ( abs ( temp - x ) < xtol ) then ! Convergence as the change in root is within tolerance xcnvrg = . true . exit end if end if ! Update function values ff = fcn % fcn ( x ) df = fcn % diff ( x , ff ) neval = neval + 1 ndiff = ndiff + 1 ! Check for convergence if ( abs ( ff ) < ftol ) then fcnvrg = . true . exit end if if ( abs ( dx ) < xtol ) then xcnvrg = . true . exit end if if ( abs ( df ) < dtol ) then dcnvrg = . true . exit end if ! Update the bracket on the root if ( ff < zero ) then xl = x else xh = x end if ! Print status if ( this % get_print_status ()) then call print_status ( iter , neval , ndiff , dx , ff ) end if ! Ensure we haven't made too many function evaluations if ( neval >= maxeval ) then flag = 1 exit end if end do ! Ensure the function value is current with the estimate of the root if ( present ( f )) then f = fcn % fcn ( x ) neval = neval + 1 end if ! Report out iteration statistics and other optional outputs if ( present ( f )) f = ff if ( present ( ib )) then ib % iter_count = iter ib % fcn_count = neval ib % jacobian_count = ndiff ib % gradient_count = 0 ib % converge_on_fcn = fcnvrg ib % converge_on_chng = xcnvrg ib % converge_on_zero_diff = dcnvrg end if ! Check for convergence issues if ( flag /= 0 ) then write ( errmsg , 101 ) \"The algorithm failed to \" // & \"converge.  Function evaluations performed: \" , neval , & \".\" // new_line ( 'c' ) // \"Root estimate: \" , x , & new_line ( 'c' ) // \"Residual: \" , ff call errmgr % report_error ( \"newt1var_solve\" , trim ( errmsg ), & NL_CONVERGENCE_ERROR ) end if ! Format 100 format ( A , E10 . 3 , A , E10 . 3 ) 101 format ( A , I0 , A , E10 . 3 , A , E10 . 3 ) end subroutine end module","tags":"","loc":"sourcefile\\nonlin_solve.f90.html"},{"title":"nonlin_types.f90 – NONLIN","text":"Contents Modules nonlin_types Source Code nonlin_types.f90 Source Code module nonlin_types use iso_fortran_env implicit none private public :: iteration_behavior public :: value_pair type iteration_behavior !! Defines a set of parameters that describe the behavior of the !! iteration process. integer ( int32 ) :: iter_count !! Specifies the number of iterations performed. integer ( int32 ) :: fcn_count !! Specifies the number of function evaluations performed. integer ( int32 ) :: jacobian_count !! Specifies the number of Jacobian evaluations performed. integer ( int32 ) :: gradient_count !! Specifies the number of gradient vector evaluations performed. logical :: converge_on_fcn !! True if the solution converged as a result of a zero-valued !! function; else, false. logical :: converge_on_chng !! True if the solution converged as a result of no appreciable !! change in solution points between iterations; else, false. logical :: converge_on_zero_diff !! True if the solution appears to have settled on a stationary !! point such that the gradient of the function is zero-valued; !! else, false. end type type value_pair !! Defines a pair of numeric values. real ( real64 ) :: x1 !! Value 1. real ( real64 ) :: x2 !! Value 2. end type end module","tags":"","loc":"sourcefile\\nonlin_types.f90.html"}]}